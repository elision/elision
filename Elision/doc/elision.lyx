#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass amsbook
\begin_preamble
%%\usepackage{minted}
\definecolor{shadecolor}{rgb}{0.8,0.8,1}
\sloppypar
%\usepackage{nameref}
\usepackage{fancybox}
\newenvironment{elision}{%
\VerbatimEnvironment
\begin{lstlisting}%
}{%
\end{lstlisting}%
}
\definecolor{listing}{RGB}{224,224,224}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "backgroundcolor={\color{listing}},basewidth={.5em},basicstyle={\ttfamily\small},columns=fixed,commentstyle={\color{blue}\emph},language=Java,morecomment={[l]{e>}},morecomment={[l]{q>}},morecomment={[l]{\ >}},numbers=none"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Elision User Guide
\end_layout

\begin_layout Dedicatory
Version @VERSION@ Build @DSTAMP@@TSTAMP@
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
Elision is distributed under the following modified BSD 
\begin_inset Quotes eld
\end_inset

two clause
\begin_inset Quotes erd
\end_inset

 license.
\end_layout

\begin_layout LyX-Code
      _ _     _
\end_layout

\begin_layout LyX-Code
  ___| (_)___(_) ___  _ __
\end_layout

\begin_layout LyX-Code
 / _ 
\backslash
 | / __| |/ _ 
\backslash
| '_ 
\backslash

\end_layout

\begin_layout LyX-Code
|  __/ | 
\backslash
__ 
\backslash
 | (_) | | | |
\end_layout

\begin_layout LyX-Code
 
\backslash
___|_|_|___/_|
\backslash
___/|_| |_|
\end_layout

\begin_layout LyX-Code
The Elision Term Rewriter
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
Copyright (c) 2012 by UT-Battelle, LLC.
\end_layout

\begin_layout LyX-Code
All rights reserved.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
Redistribution and use in source and binary forms, with or without
\end_layout

\begin_layout LyX-Code
modification, are permitted provided that the following conditions are met:
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
1.
 Redistributions of source code must retain the above copyright notice,
 this
\end_layout

\begin_layout LyX-Code
   list of conditions and the following disclaimer.
\end_layout

\begin_layout LyX-Code
2.
 Redistributions in binary form must reproduce the above copyright notice,
\end_layout

\begin_layout LyX-Code
   this list of conditions and the following disclaimer in the documentation
\end_layout

\begin_layout LyX-Code
   and/or other materials provided with the distribution.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
Collection of administrative costs for redistribution of the source code
 or
\end_layout

\begin_layout LyX-Code
binary form is allowed.
 However, collection of a royalty or other fee in excess
\end_layout

\begin_layout LyX-Code
of good faith amount for cost recovery for such redistribution is prohibited.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 IS"
\end_layout

\begin_layout LyX-Code
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
\end_layout

\begin_layout LyX-Code
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
\end_layout

\begin_layout LyX-Code
ARE DISCLAIMED.
 IN NO EVENT SHALL THE COPYRIGHT HOLDER, THE DOE, OR
\end_layout

\begin_layout LyX-Code
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
\end_layout

\begin_layout LyX-Code
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
\end_layout

\begin_layout LyX-Code
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
\end_layout

\begin_layout LyX-Code
OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
\end_layout

\begin_layout LyX-Code
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
\end_layout

\begin_layout LyX-Code
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
\end_layout

\begin_layout LyX-Code
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\end_layout

\begin_layout Chapter
Installation
\end_layout

\begin_layout Standard
This chapter explains how to build the Elision rewriter.
 Information about the rewriter can be obtained by visiting 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://stacyprowell.com/wiki/doku.php?id=elision
\end_layout

\end_inset

.
 This page contains a frequently updated version, along with documentation
 links and a like to Elision's github page.
\end_layout

\begin_layout Standard
Elision contains Parboiled, a parser expression grammar (PEG) library.
 See 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/sirthias/parboiled/wiki
\end_layout

\end_inset

 for details, including the license agreement.
 The Elision REPL uses JLine2, a Java library for handling console input.
 See 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/jline/jline2
\end_layout

\end_inset

 for details, including the license agreement.
 Note that Elision actually uses the modified version of JLine built for
 the Scala REPL.
\end_layout

\begin_layout Section
Prerequisites
\end_layout

\begin_layout Standard
Elision requires Scala 2.9 or later to build.
 Be careful with later versions of Scala as the language is still changing
 quite a bit.
 Java 6 or later and Apache Ant 1.8 or later are also prerequisites.
\end_layout

\begin_layout Enumerate
Install the Java 6 (or later) SDK.
 Visit 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://java.oracle.com
\end_layout

\end_inset

 to download the correct version for your platform.
\end_layout

\begin_layout Enumerate
Install Scala 2.9.1 (or later).
 Visit 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.scala-lang.org
\end_layout

\end_inset

 to download the Scala distribution.
\end_layout

\begin_layout Enumerate
Set the environment variable 
\family typewriter
SCALA_HOME
\family default
 to point to the root folder of your Scala installation (the folder that
 contains the 
\family typewriter
bin
\family default
 and 
\family typewriter
lib
\family default
 folders).
\end_layout

\begin_deeper
\begin_layout Enumerate
On Windows platforms you should edit the environment variable settings under
 System, and add 
\family typewriter
%SCALA_HOME%
\backslash
bin
\family default
 to the 
\family typewriter
Path
\family default
 environment variable.
 Open 
\family sans
System Properties
\family default
 and click 
\family sans
Advanced system settings
\family default
.
 Then on the 
\family sans
Advanced
\family default
 tab click 
\family sans
Environment Variables...

\family default
 Under 
\family sans
System Variables
\family default
 click 
\family sans
New...
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Variable name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Variable value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
SCALA_HOME
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
C:
\backslash
scala
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
You should replace 
\family typewriter
C:
\backslash
scala
\family default
 with the directory where you installed Scala.
 Next edit the value for 
\family typewriter
Path
\family default
 
\emph on
carefully
\emph default
 to add 
\family typewriter
;%SCALA_HOME%
\backslash
bin
\family default
 on the end.
\end_layout

\end_deeper
\begin_layout Enumerate
On MacOS X platforms you can edit the environment plist 
\emph on
or
\emph default
 follow the directions for UNIX below.
 You can do this from the Terminal prompt with 
\family typewriter
open ~/.MacOSX/environment.plist
\family default
.
 This will open the environment settings in the 
\family sans
Property List Editor
\family default
.
 Add a new 
\family sans
Item
\family default
 at the top level.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Key
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
SCALA_HOME
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
/usr/local/scala
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
You should replace 
\family typewriter
/usr/local/scala
\family default
 with the directory where you installed Scala.
 Next edit the value for 
\family typewriter
PATH
\family default
 
\emph on
carefully
\emph default
 to add 
\family typewriter
:$SCALA_HOME/bin
\family default
 on the end.
\end_layout

\end_deeper
\begin_layout Enumerate
On modern UNIX systems (including MacOS X) and most Linux systems you can
 create a 
\family typewriter
/etc/profile.d/scala.sh
\family default
 file with the following content:
\end_layout

\begin_deeper
\begin_layout LyX-Code
# Add Scala
\begin_inset Newline newline
\end_inset

export SCALA_HOME=/usr/local/scala
\begin_inset Newline newline
\end_inset

PATH=${PATH}:$SCALA_HOME/bin
\end_layout

\begin_layout Standard
You should replace 
\family typewriter
/usr/local/scala
\family default
 with the directory where you installed Scala.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
(Optional) It is recommended to get the Scala developer documentation package.
 After you have installed Scala, run the following command at the prompt.
 If you have installed Scala in a folder owned by root on Linux or UNIX,
 you will need to precede the command with 
\family typewriter
sudo
\family default
.
\begin_inset Newline newline
\end_inset


\family typewriter
sbaz install scala-devel-docs
\end_layout

\begin_layout Enumerate
Install Apache Ant 1.8 (or later).
 Visit 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://ant.apache.org
\end_layout

\end_inset

 to download the Ant distribution.
\end_layout

\begin_layout Enumerate
If you want to use Eclipse, you should install Eclipse Indigo (or later).
\end_layout

\begin_layout Section
Building
\end_layout

\begin_layout Standard
To build the Elision jar file, 
\family typewriter
cd
\family default
 to the root folder of the Elision distribution and run the command 
\family typewriter
ant
\family default
.
 This will build the jar file.
 If you want to build the API documentation, then run the command 
\family typewriter
ant docs
\family default
.
 To do both, use 
\family typewriter
ant all
\family default
.
 To see what other targets are available, use 
\family typewriter
ant -p
\family default
.
\end_layout

\begin_layout Section
REPL
\end_layout

\begin_layout Standard
Elision comes with a read, evaluate, print loop interpreter (a REPL).
 You can start it in any of the following ways.
\end_layout

\begin_layout Itemize
Use the 
\family typewriter
repl.sh
\family default
 script found in the root folder of the Elision distribution.
 This starts the REPL using the compiled class files in the 
\family typewriter
bin
\family default
 folder, and is the best way to run it if you are using a continuous build
 system such as Eclipse.
 If you try to run the REPL this way while Eclipse is compiling, you will
 get missing class file errors.
 Just wait for Eclipse to finish compiling.
\end_layout

\begin_layout Itemize
To run the REPL from the jar file, execute the command 
\family typewriter
scala elision.jar
\family default
.
 If the Scala library is available in 
\family typewriter
scala-library.jar
\family default
 then you can also run it with 
\family typewriter
java -cp scala-library.jar -jar elision.jar
\family default
.
 You must have built the jar file to use this method, and must update it
 each time you make changes.
\end_layout

\begin_layout Itemize
To start the REPL from inside a program, invoke the 
\family typewriter
sjp.elision.repl.Repl.run()
\family default
 method.
\end_layout

\begin_layout Standard
To exit from the REPL use 
\family typewriter
:quit
\family default
.
 To get help use 
\family typewriter
help()
\family default
.
 The REPL is the subject of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Interacting-with-the"

\end_inset

.
\end_layout

\begin_layout Section
Emacs, Notepad-Plus, and Others
\end_layout

\begin_layout Standard
Most editors now come with a Scala mode installed.
 In case yours does not, you should look in the Scala distribution under
 
\family typewriter
misc/scala-tool-support
\family default
.
 We will provide some instructions for Emacs here.
\end_layout

\begin_layout Standard
The Emacs mode works for Emacs 21.1or later, and does not work on XEmacs.
 Things change; consult the 
\family typewriter
README
\family default
 file in the folder for current details.
 It is suggested you leave these files in place so they get magically updated
 when the next version of Scala is installed.
\end_layout

\begin_layout Standard
In your Emacs startup file (typically 
\family typewriter
~/.emacs
\family default
 on Linux or UNIX) add the following two lines.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp"
inline false
status open

\begin_layout Plain Layout

(add-to-list 'load-path
\end_layout

\begin_layout Plain Layout

  "/usr/local/scala/misc/scala-tool-support/emacs")
\end_layout

\begin_layout Plain Layout

(require 'scala-mode-auto)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Adjust the second line as necessary to point to your Scala installation.
 Now restart Emacs, and you should get the Scala mode when you open a file
 ending with 
\family typewriter
.scala
\family default
.
 You can compile the 
\family typewriter
.el
\family default
 files to 
\family typewriter
.elc
\family default
 files using the provided 
\family typewriter
Makefile
\family default
, but be sure to run 
\family typewriter
make
\family default
 each time you update.
\end_layout

\begin_layout Section
Eclipse
\end_layout

\begin_layout Standard
The root folder of the Elision distribution contains an Eclipse project.
 Before you attempt to import it into Eclipse you should do the following.
\end_layout

\begin_layout Itemize
Install the 
\series bold
Scala IDE
\series default
.
 At present the version of the Scala IDE for Scala 2.9 can be found at the
 update site 
\begin_inset CommandInset href
LatexCommand href
target "http://download.scala-ide.org/releases-29/stable/site"

\end_inset

.
 Visit 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://scala-ide.org
\end_layout

\end_inset

 for the latest version, documentation, etc.
\end_layout

\begin_layout Standard
That is all that is required.
 You may optionally install the following helpful plugins.
\end_layout

\begin_layout Itemize

\series bold
ShellEd
\series default
 is an excellent editor for working with shell scripts, but at present it
 only works with Eclipse Indigo.
 You can find out more at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://sourceforge.net/apps/trac/shelled
\end_layout

\end_inset

.
 To install ShellEd you need to install components from the Linux Tools.
 The update site is 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://download.eclipse.org/technology/linuxtools/update
\end_layout

\end_inset

.
 Add this update site first, but do not install anything.
 The update site for ShellEd is 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://downloads.sourceforge.net/project/shelled/shelled/ShellEd%202.0.1/update
\end_layout

\end_inset

.
 After adding the update site for the Linux Tools, add this update site
 and then install ShellEd; it will resolve the dependencies and get the
 components from the Linux Tools that are actually required.
\end_layout

\begin_layout Itemize

\series bold
Copyright Wizard
\series default
 can be used to automatically and quickly update the copyrights on all files
 and to make sure all new files have the correct copyright information.
 The distribution includes a configuration file for Copyright Wizard that
 will be automatically discovered if you install Copyright Wizard.
 Find out more at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.wdev91.com/?p=cpw
\end_layout

\end_inset

.
 The update site is 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.wdev91.com/update
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Once you have installed the Scala IDE plugin, do the following.
\end_layout

\begin_layout Enumerate
Unpack the Elision distribution into an Eclipse workspace, or create a 
\family typewriter
workspace
\family default
 folder and place the 
\family typewriter
Elision
\family default
 folder in it.
\end_layout

\begin_layout Enumerate
Start Eclipse.
 You will probably be prompted to run the Scala Setup Diagnostics.
 Click Yes to run them.
 Make sure you open Eclipse in the correct workspace containing the Elision
 distribution.
\end_layout

\begin_layout Enumerate
Go to the workbench.
 Right-click in the package explorer and choose New and then Project.
 In the New Project wizard expand Scala Wizards and select Scala Project.
 Click Next.
\end_layout

\begin_layout Enumerate
In the New Scala Project dialog enter Elision as the project name.
 If you have done everything correctly you should see a note at the bottom
 of the dialog telling you the wizard is about to automatically configure
 the project based on the existing source.
 This is what you want, so click Finish.
\end_layout

\begin_layout Enumerate
You may be asked if you want to switch to the Scala perspective.
 You do, so click Yes.
\end_layout

\begin_layout Standard
At this point Elision should automatically build, and you are ready to start
 working with the code or running the REPL using 
\family typewriter
repl.sh
\family default
.
\end_layout

\begin_layout Section
Scala Code
\end_layout

\begin_layout Standard
Elision is written in Scala, and provides a Scala API.
 Discussions of the Scala API are highlighted in blue.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Elision's classes live in packages under 
\family typewriter
sjp.elision
\family default
.
 Throughout this document packages, classes, objects, traits, etc., will
 be discussed in reference to this top-level package.
 Thus 
\family typewriter
core.BasicAtom
\family default
 refers to the fully-qualified class name (FQCN) 
\family typewriter
sjp.elision.core.BasicAtom
\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Interacting-with-the"

\end_inset

Interacting with the REPL
\end_layout

\begin_layout Standard
The REPL is Elision's read, evaluate, print loop.
 It provides a way to interact directly with the rewriter.
\end_layout

\begin_layout Section
Starting the REPL
\end_layout

\begin_layout Standard
You can start the REPL in any of the following ways.
\end_layout

\begin_layout Itemize
Use the 
\family typewriter
repl.sh
\family default
 script found in the root folder of the Elision distribution.
 This starts the REPL using the compiled class files in the 
\family typewriter
bin
\family default
 folder, and is the best way to run it if you are using a continuous build
 system such as Eclipse.
\end_layout

\begin_layout Itemize
To run the REPL from the jar file, execute the command 
\family typewriter
scala elision.jar
\family default
.
 If the Scala library is available in 
\family typewriter
scala-library.jar
\family default
 then you can also run it with 
\family typewriter
java -cp scala-library.jar -jar elision.jar
\family default
.
\end_layout

\begin_layout Itemize
To start the REPL from inside a program, invoke the 
\family typewriter
sjp.elision.repl.Repl.run()
\family default
 method.
 This is useful from the Scala prompt, assuming you have the correct 
\family typewriter
CLASSPATH
\family default
.
 You can use the 
\family typewriter
run.sh
\family default
 script found in the Elision root to start Scala with the correct 
\family typewriter
CLASSPATH
\family default
.
\end_layout

\begin_layout Standard
All of these methods will display the Elision banner and present you with
 the REPL prompt 
\family typewriter
e>
\family default
.
 You can enter text to be evaluated as an Elision atom (described in later
 sections), interact with the history (using the up and down arrow keys),
 or edit the current line.
 Pressing Enter submits the line to the Elision parser for evaluation.
\end_layout

\begin_layout Standard
The most useful commands to know immediately are 
\family typewriter
help()
\family default
 (to get help) and 
\family typewriter
:quit
\family default
 (to quit).
\end_layout

\begin_layout Standard
The REPL commands (with the exception of 
\family typewriter
:quit
\family default
 and history recall) are actually Elision operators (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Operators"

\end_inset

).
 As such you must follow them with parentheses; otherwise the Elision REPL
 will interpret them as symbols.
 Try 
\family typewriter
history
\family default
 and then try 
\family typewriter
history()
\family default
.
\end_layout

\begin_layout Standard
The REPL reads zero or more atoms per line, evaluates them, and displays
 the output.
 Several atoms can be present on a single line; in that case the REPL displays
 each one.
\end_layout

\begin_layout Standard
Atoms can span multiple lines.
 If a parenthesis, brace, or quotation mark is open at the end of the line,
 then the REPL will prompt for additional input with the prompt 
\family typewriter
>
\family default
.
 The newlines are converted to spaces.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> { operator
\end_layout

\begin_layout Plain Layout

 >   #name=set
\end_layout

\begin_layout Plain Layout

 >   #params=%ACI($P: BOOLEAN, $Q: BOOLEAN)
\end_layout

\begin_layout Plain Layout

 >   #type=BOOLEAN
\end_layout

\begin_layout Plain Layout

 > }
\end_layout

\begin_layout Plain Layout

$repl0 = {: operator:SYMBOL { binds name -> set:SYMBOL
\end_layout

\begin_layout Plain Layout

  params -> %ACI($P:BOOLEAN, $Q:BOOLEAN) type -> BOOLEAN } :}
\end_layout

\begin_layout Plain Layout

e> "
\end_layout

\begin_layout Plain Layout

 > Fred
\end_layout

\begin_layout Plain Layout

 > "
\end_layout

\begin_layout Plain Layout

$repl1 = " Fred "
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
History
\end_layout

\begin_layout Standard
The Elision REPL saves a persistent history from session to session.
 This history can be viewed with the 
\family typewriter
history()
\family default
 command.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> history()
\end_layout

\begin_layout Plain Layout

1: {operator #name=test #params=%($x:INTEGER) #type=INTEGER}
\end_layout

\begin_layout Plain Layout

2: {rule add($x,neg($x)) -> 0}
\end_layout

\begin_layout Plain Layout

3: add(21,17,$x)
\end_layout

\begin_layout Plain Layout

4: history()
\end_layout

\begin_layout Plain Layout

Persistent history is found in: /home/userguy/.elision
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is possible to recall any prior history element by entering the history
 index after an exclamation mark.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> !3
\end_layout

\begin_layout Plain Layout

add(21,17,$x)
\end_layout

\begin_layout Plain Layout

$repl14 = add($x, 38)
\end_layout

\begin_layout Plain Layout

e> bind($x, 2)
\end_layout

\begin_layout Plain Layout

Bound $x
\end_layout

\begin_layout Plain Layout

e> !3
\end_layout

\begin_layout Plain Layout

add(21,17,$x)
\end_layout

\begin_layout Plain Layout

$repl15 = 40
\end_layout

\begin_layout Plain Layout

e> history()
\end_layout

\begin_layout Plain Layout

1: {native neg($x:INTEGER):INTEGER}
\end_layout

\begin_layout Plain Layout

2: {rule add($x,neg($x)) -> 0}
\end_layout

\begin_layout Plain Layout

3: add(21,17,$x)
\end_layout

\begin_layout Plain Layout

4: history()
\end_layout

\begin_layout Plain Layout

5: add(21,17,$x)
\end_layout

\begin_layout Plain Layout

6: bind($x, 2)
\end_layout

\begin_layout Plain Layout

7: add(21,17,$x)
\end_layout

\begin_layout Plain Layout

8: history()
\end_layout

\begin_layout Plain Layout

Persistent history is found in: /home/userguy/.elision
\end_layout

\end_inset


\end_layout

\begin_layout Section
Binding
\end_layout

\begin_layout Standard
We can tell the Elision system that we want to replace the variable 
\family typewriter
$x
\family default
 with the value 
\family typewriter
7
\family default
 wherever it appears.
 We say the variable 
\family typewriter
$x
\family default
 is 
\emph on
bound
\emph default
 to 
\family typewriter
7
\family default
, and that the pair 
\family typewriter
$x
\family default
 and 
\family typewriter
7
\family default
 is a 
\emph on
binding
\emph default
, written 
\family typewriter
$x -> 7
\family default
.
 When we replace the variable 
\family typewriter
$x
\family default
 with 
\family typewriter
7
\family default
 in some other term, we say we are 
\emph on
rewriting
\emph default
 the term with the binding.
 The REPL keeps a set of bindings that are used to immediately rewrite any
 atom 
\emph on
after
\emph default
 it is parsed and constructed.
 For instance, if the variable 
\family typewriter
$x
\family default
 is bound to 
\family typewriter
7
\family default
, then entering 
\family typewriter
$x
\family default
 at the prompt results in the value 
\family typewriter
7
\family default
.
\end_layout

\begin_layout Standard
The 
\family typewriter
bind(
\emph on
v
\emph default
,
\emph on
a
\emph default
)
\family default
 command binds a variable 
\family typewriter
\emph on
v
\family default
\emph default
 to an atom 
\family typewriter
\emph on
a
\family default
\emph default
.
 For instance, try 
\family typewriter
bind($x,7)
\family default
 and 
\family typewriter
bind($y,
\backslash
$x.%($x,$x))
\family default
.
 Then try 
\family typewriter
$x
\family default
 and 
\family typewriter
$y
\family default
 at the prompt.
 Then try 
\family typewriter
$y.$x
\family default
.
 Variables can be rebound at any time, and there is no need to 
\begin_inset Quotes eld
\end_inset

unbind
\begin_inset Quotes erd
\end_inset

 them first.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> bind($x,7)
\end_layout

\begin_layout Plain Layout

Bound $x
\end_layout

\begin_layout Plain Layout

e> bind($y,
\backslash
$x.%($x,$x))
\end_layout

\begin_layout Plain Layout

Bound $y
\end_layout

\begin_layout Plain Layout

e> $x
\end_layout

\begin_layout Plain Layout

$repl16 = 7
\end_layout

\begin_layout Plain Layout

e> $y
\end_layout

\begin_layout Plain Layout

$repl17 = 
\backslash
$`:1`.%($`:1`, $`:1`)
\end_layout

\begin_layout Plain Layout

e> $y.$x
\end_layout

\begin_layout Plain Layout

$repl18 = %(7, 7)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
unbind(
\emph on
v
\emph default
)
\family default
 command removes any binding for the variable 
\family typewriter
\emph on
v
\family default
\emph default
.
 Try 
\family typewriter
unbind($x)
\family default
 and then repeat 
\family typewriter
$y.$x
\family default
.
 No error is generated if a variable is not bound.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> unbind($x)
\end_layout

\begin_layout Plain Layout

Unbound $x
\end_layout

\begin_layout Plain Layout

e> $y.$x
\end_layout

\begin_layout Plain Layout

$repl19 = %($x, $x)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Every time an atom is evaluated by the REPL, the result is displayed and
 then bound to a new variable whose name starts with 
\family typewriter
$repl
\family default
 followed by a number.
 These variables are displayed on the output.
 Try 
\family typewriter
$repl1
\family default
.
\end_layout

\begin_layout Standard
To see all the bindings being used by the shell, enter the command 
\family typewriter
showbinds()
\family default
.
\end_layout

\begin_layout Section
Atom Display
\end_layout

\begin_layout Standard
When you type an atom at the REPL prompt the system parses the atom and
 constructs it.
 Several operators are understood by the REPL, and these are handled immediately.
 Otherwise the current bindings are applied to the atom, and the atom is
 then rewritten using any active rulesets.
 The result of this is then bound to the next 
\family typewriter
$repl
\family default
\emph on
n
\emph default
 variable.
\end_layout

\begin_layout Standard
You can see the atom after it is parsed and constructed, but before bindings
 are applied and rewriting is performed, by executing the 
\family typewriter
showprior()
\family default
 command.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> bind($x,10)
\end_layout

\begin_layout Plain Layout

Bound $x
\end_layout

\begin_layout Plain Layout

e> showprior()
\end_layout

\begin_layout Plain Layout

Showing prior term is ON.
\end_layout

\begin_layout Plain Layout

e> add($x,$x,0)
\end_layout

\begin_layout Plain Layout

add($x, $x)
\end_layout

\begin_layout Plain Layout

$repl20 = 20
\end_layout

\begin_layout Plain Layout

e> showprior()
\end_layout

\begin_layout Plain Layout

Showing prior term is OFF.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The atom as entered was 
\family typewriter
add($x,$x,0)
\family default
.
 During construction the identity 
\family typewriter
0
\family default
 is removed, leaving the atom 
\family typewriter
add($x,$x)
\family default
, which is displayed.
 Then the bindings are applied, yielding 
\family typewriter
add(10,10)
\family default
, which is rewritten to 
\family typewriter
20
\family default
 and displayed as the final result.
 Entering 
\family typewriter
showprior()
\family default
 again disables printing the prior atom.
\end_layout

\begin_layout Standard
Most REPL printing can be suppressed using the 
\family typewriter
quiet()
\family default
 command.
 This changes the prompt to 
\family typewriter
q>
\family default
.
 Only explicitly requested output is displayed in this mode.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
It is possible to display the Scala code to create the atom.
 This is enabled (and disabled) with 
\family typewriter
showscala()
\family default
.
 The assumed context for the resulting code is that the content of the 
\family typewriter
core
\family default
 package is imported.
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> showscala()
\end_layout

\begin_layout Plain Layout

Showing Scala is ON.
\end_layout

\begin_layout Plain Layout

e> 
\backslash
$x:$T.$T
\end_layout

\begin_layout Plain Layout

Scala: $repl28 = Lambda(Variable(Variable(NamedRootType("ANY"), "T", BooleanLite
ral(NamedRootType("BOOLEAN"), true), Set()), ":1", BooleanLiteral(NamedRootType(
"BOOLEAN"), true), Set()), Variable(NamedRootType("ANY"), "T", BooleanLiteral(Na
medRootType("BOOLEAN"), true), Set()))
\end_layout

\begin_layout Plain Layout

$repl28 = 
\backslash
$`:1`:$T.$T
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
This can be useful to discover how to construct an atom using the Scala
 API.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Automatic Rewriting
\end_layout

\begin_layout Standard
Once an atom is entered and bindings are applied, it is rewritten with the
 active rulesets.
 (Applying rules is the subject of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Rules-and-Strategies"

\end_inset

.)
\end_layout

\begin_layout Standard
Rulesets are initially disabled when declared.
 They can be 
\emph on
enabled
\emph default
 using the 
\family typewriter
enable(RS)
\family default
 command, where 
\family typewriter
RS
\family default
 is the name of the ruleset.
 Likewise, they can be 
\emph on
disabled
\emph default
 with the 
\family typewriter
disable(RS)
\family default
 command.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> if (true, 6, 7)
\end_layout

\begin_layout Plain Layout

$repl19 = if(true, 6, 7)
\end_layout

\begin_layout Plain Layout

e> enable(IF)
\end_layout

\begin_layout Plain Layout

e> if (true, 6, 7)
\end_layout

\begin_layout Plain Layout

$repl20 = 6
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A limit is placed on the number of times a rule can be applied to rewrite
 an atom.
 This limit can be set via the 
\family typewriter
setlimit(lim)
\family default
 command, where 
\family typewriter
lim
\family default
 is the new limit.
 Automatic rewriting is on by default, but can be disabled (or re-enabled)
 altogether with the 
\family typewriter
rewrite()
\family default
 command.
\end_layout

\begin_layout Standard
You can ask the system which rules may be applied to an atom, using the
 
\family typewriter
showrules(atom)
\family default
 command, where 
\family typewriter
atom
\family default
 is the atom to test.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> showrules(if (true, 6, 7))
\end_layout

\begin_layout Plain Layout

{ RULE if(true, $thenpart, $elsepart) -> $thenpart rulesets IF level 2 }
\end_layout

\begin_layout Plain Layout

{ RULE if(false, $thenpart, $elsepart) -> $elsepart rulesets IF level 2
 } 
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
Understanding Matching
\end_layout

\begin_layout Standard
To support better understanding of the matching process, it is possible
 to enable (or disable) tracing the matching process with the 
\family typewriter
tracematch()
\family default
 command.
 When enabled considerable diagnostic information is printed for every match
 that is attempted.
\end_layout

\begin_layout Standard
Several things trigger the matching system.
 One is constructing an operator application, where arguments are matched
 against the formal parameters.
 Another is matching a lambda argument to the parameter.
 Of course, the most obvious way is by explicitly trying to match two atoms.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> tracematch()
\end_layout

\begin_layout Plain Layout

Match tracing is ON.
\end_layout

\begin_layout Plain Layout

e> 
\backslash
$x:$T.$T.add:OPTYPE
\end_layout

\begin_layout Plain Layout

Sequence Matcher called: $domain,$codomain -> $T,ANY / { bind  }
\end_layout

\begin_layout Plain Layout

TRYING  (cceafb50) in class sjp.elision.core.Variable:
\end_layout

\begin_layout Plain Layout

  pattern: $domain
\end_layout

\begin_layout Plain Layout

  subject: $T
\end_layout

\begin_layout Plain Layout

  with: { bind  }
\end_layout

\begin_layout Plain Layout

SUCCESS (cceafb50): { bind domain -> $T }
\end_layout

\begin_layout Plain Layout

TRYING  (ba5fa5c) in class sjp.elision.core.Variable:
\end_layout

\begin_layout Plain Layout

  pattern: $codomain
\end_layout

\begin_layout Plain Layout

  subject: ANY
\end_layout

\begin_layout Plain Layout

  with: { bind domain -> $T }
\end_layout

\begin_layout Plain Layout

SUCCESS (ba5fa5c): { bind domain -> $T }
\end_layout

\begin_layout Plain Layout

TRYING  (94a4e9fe) in class sjp.elision.core.Lambda$$anon$1:
\end_layout

\begin_layout Plain Layout

  pattern: $`:1`:$T
\end_layout

\begin_layout Plain Layout

  subject: add:OPTYPE
\end_layout

\begin_layout Plain Layout

  with: { bind  }
\end_layout

\begin_layout Plain Layout

Sequence Matcher called: $`::1`,$`::2` -> INTEGER,INTEGER / { bind  }
\end_layout

\begin_layout Plain Layout

TRYING  (e4055fd3) in class sjp.elision.core.Variable:
\end_layout

\begin_layout Plain Layout

  pattern: $`::1`
\end_layout

\begin_layout Plain Layout

  subject: INTEGER
\end_layout

\begin_layout Plain Layout

  with: { bind  }
\end_layout

\begin_layout Plain Layout

SUCCESS (e4055fd3): { bind `::1` -> INTEGER }
\end_layout

\begin_layout Plain Layout

TRYING  (e4055ff2) in class sjp.elision.core.Variable:
\end_layout

\begin_layout Plain Layout

  pattern: $`::2`
\end_layout

\begin_layout Plain Layout

  subject: INTEGER
\end_layout

\begin_layout Plain Layout

  with: { bind `::1` -> INTEGER }
\end_layout

\begin_layout Plain Layout

SUCCESS (e4055ff2): { bind `::1` -> INTEGER, `::2` -> INTEGER }
\end_layout

\begin_layout Plain Layout

Sequence Matcher called: $domain,$codomain -> xx(INTEGER, INTEGER),INTEGER
 / { bind  }
\end_layout

\begin_layout Plain Layout

TRYING  (516c94d7) in class sjp.elision.core.Variable:
\end_layout

\begin_layout Plain Layout

  pattern: $domain
\end_layout

\begin_layout Plain Layout

  subject: xx(INTEGER, INTEGER)
\end_layout

\begin_layout Plain Layout

  with: { bind  }
\end_layout

\begin_layout Plain Layout

SUCCESS (516c94d7): { bind domain -> xx(INTEGER, INTEGER) }
\end_layout

\begin_layout Plain Layout

TRYING  (b28a4874) in class sjp.elision.core.Variable:
\end_layout

\begin_layout Plain Layout

  pattern: $codomain
\end_layout

\begin_layout Plain Layout

  subject: INTEGER
\end_layout

\begin_layout Plain Layout

  with: { bind domain -> xx(INTEGER, INTEGER) }
\end_layout

\begin_layout Plain Layout

SUCCESS (b28a4874): { bind domain -> xx(INTEGER, INTEGER), codomain -> INTEGER
 }
\end_layout

\begin_layout Plain Layout

TRYING  (2b270a36) in class sjp.elision.core.Variable:
\end_layout

\begin_layout Plain Layout

  pattern: $T
\end_layout

\begin_layout Plain Layout

  subject: MAP(xx(INTEGER, INTEGER), INTEGER)
\end_layout

\begin_layout Plain Layout

  with: { bind  }
\end_layout

\begin_layout Plain Layout

SUCCESS (2b270a36): { bind T -> MAP(xx(INTEGER, INTEGER), INTEGER) }
\end_layout

\begin_layout Plain Layout

SUCCESS (94a4e9fe): { bind `:1` -> add:OPTYPE, T -> MAP(xx(INTEGER, INTEGER),
 INTEGER) }
\end_layout

\begin_layout Plain Layout

$repl21 = MAP(xx(INTEGER, INTEGER), INTEGER)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Reading this trace can be tricky.
 The sequence matcher tries to perform an in-order pairwise match of two
 sequences of atoms, given some set of bindings.
 For example, the first line indicates that the sequence matcher was called
 to match the pattern sequence 
\family typewriter
$domain,$codomain
\family default
 against the subject sequence 
\family typewriter
$T,ANY
\family default
 with no prior bindings.
\end_layout

\begin_layout Standard
The lines that begin with 
\family typewriter
TRYING
\family default
 and 
\family typewriter
SUCCESS
\family default
 or 
\family typewriter
FAILURE
\family default
 are linked using the hexadecimal number in parentheses.
 This number is actually a hash code for the match attempt and serves to
 link together the lines.
 In a large match attempts will often interleave.
\end_layout

\begin_layout Standard
Following a 
\family typewriter
TRYING
\family default
 line the pattern, subject, and any bindings are printed.
 On 
\family typewriter
SUCCESS
\family default
 we see the bindings that result in a successful match.
 On 
\family typewriter
FAILURE
\family default
 we are told why the match failed, and the pattern and subject may be repeated.
\end_layout

\begin_layout Standard
In some cases there will be additional matching reports after the 
\family typewriter
$repl
\family default
 result is shown.
 These are due to 
\emph on
round-trip testing
\emph default
 by the system.
\begin_inset Foot
status open

\begin_layout Plain Layout
This testing is used to assure 
\emph on
referential transparency
\emph default
, and can be disabled using the 
\family typewriter
setroundtrip(false)
\family default
 command.
\end_layout

\end_inset

 This is testing that determines whether or not an atom's representation
 can be successfully re-parsed to yield the original atom, and this output
 can safely be ignored.
 Look for the line beginning with 
\family typewriter
$repl
\family default
 and ignore subsequent output.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> {match 7}.$x
\end_layout

\begin_layout Plain Layout

TRYING  (de6d60a9) in class sjp.elision.core.IntegerLiteral:
\end_layout

\begin_layout Plain Layout

  pattern: 7
\end_layout

\begin_layout Plain Layout

  subject: $x
\end_layout

\begin_layout Plain Layout

  with: { bind  }
\end_layout

\begin_layout Plain Layout

TRYING  (493d55a8) in class sjp.elision.core.INTEGER$:
\end_layout

\begin_layout Plain Layout

  pattern: INTEGER
\end_layout

\begin_layout Plain Layout

  subject: ANY
\end_layout

\begin_layout Plain Layout

  with: { bind  }
\end_layout

\begin_layout Plain Layout

SUCCESS (493d55a8): { bind  }
\end_layout

\begin_layout Plain Layout

FAILURE (de6d60a9): Literal pattern does not match subject.
\end_layout

\begin_layout Plain Layout

  pattern: 7
\end_layout

\begin_layout Plain Layout

  subject: $x
\end_layout

\begin_layout Plain Layout

$repl41 = Nothing:ANY
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For this simple example we see the inner attempt to match the types succeeds,
 and then the outer attempt to match the entire atoms fails because 
\family typewriter
7
\family default
 is a literal pattern and it can only match another literal 
\family typewriter
7
\family default
.
\end_layout

\begin_layout Section
Understanding Parsing
\end_layout

\begin_layout Standard
The parser can also be traced, and this results in an enormous quantity
 of output.
 To enable (or disable) parser tracing, use the 
\family typewriter
traceparse()
\family default
 command.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> traceparse()
\end_layout

\begin_layout Plain Layout

Parser tracing is ON.
\end_layout

\begin_layout Plain Layout

e> 7
\end_layout

\begin_layout Plain Layout

Starting new parsing run
\end_layout

\begin_layout Plain Layout

a sequence of atoms/ZeroOrMore/AtomSeqPush1Action1, matched, cursor at 1:1
 after ""
\end_layout

\begin_layout Plain Layout

..(1)../ZeroOrMore/ZeroOrMore/Sequence/an atom/LApply/a simple atom/whitespace
 or comments/FirstOf/OneOrMore/[ 
\backslash
n
\backslash
r
\backslash
t
\backslash
f], failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(9)../OneOrMore, failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(8)../FirstOf/Sequence/"/*", failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(9)../Sequence, failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(8)../FirstOf/Sequence/"//", failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(9)../Sequence, failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(8)../FirstOf, failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(7)../whitespace or comments, matched, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(6)../a simple atom/FirstOf/Sequence/'(', failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(8)../Sequence, failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(7)../FirstOf/a ruleset declaration/'{', failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(8)../a ruleset declaration, failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(7)../FirstOf/a rewrite rule/'{', failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(8)../a rewrite rule, failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

..(3)../Sequence, failed, cursor at 1:2 after "7"
\end_layout

\begin_layout Plain Layout

..(2)../FirstOf/Sequence/"//", failed, cursor at 1:2 after "7"
\end_layout

\begin_layout Plain Layout

..(3)../Sequence, failed, cursor at 1:2 after "7"
\end_layout

\begin_layout Plain Layout

..(2)../FirstOf, failed, cursor at 1:2 after "7"
\end_layout

\begin_layout Plain Layout

..(1)../whitespace or comments, matched, cursor at 1:2 after "7"
\end_layout

\begin_layout Plain Layout

a sequence of atoms/EOI, matched, cursor at 1:3 after "7"
\end_layout

\begin_layout Plain Layout

a sequence of atoms, matched, cursor at 1:3 after "7"
\end_layout

\begin_layout Plain Layout

$repl14 = 7
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Many, many lines are omitted from the above.
 The number shows the depth of the parse which, for this example, reaches
 16.
 Note that, as with match tracing, the round trip testing results in additional
 output that can be ignored.
\end_layout

\begin_layout Chapter
Basic Atoms
\end_layout

\begin_layout Standard
The objects manipulated by Elision are called 
\emph on
atoms
\emph default
, and they exist in several forms.
\end_layout

\begin_layout Itemize

\emph on
Literals
\emph default
 that denote a simple, fixed value.
\end_layout

\begin_layout Itemize

\emph on
Variables
\emph default
 denote an unspecified atom, perhaps with type information.
\end_layout

\begin_layout Itemize

\emph on
Lambdas
\emph default
 denote simple unnamed functions of one parameter.
\end_layout

\begin_layout Itemize

\emph on
Applies
\emph default
 denote an ordered pair consisting of a left-hand element often called the
 
\emph on
operator
\emph default
 and a right-hand element often called the 
\emph on
argument
\emph default
.
\end_layout

\begin_layout Itemize

\emph on
Operators
\emph default
 denote a mapping.
\end_layout

\begin_layout Itemize

\emph on
Rewriters
\emph default
 transform an atom into a potentially new form, reporting whether this transform
ation succeeded.
\end_layout

\begin_layout Standard
Atoms can be combined to make composite atoms
\begin_inset Foot
status open

\begin_layout Plain Layout
No, not molecules.
 This is not chemistry.
\end_layout

\end_inset

 in a variety of ways.
 These are discussed in the following sections and chapters.
\end_layout

\begin_layout Section
Types
\end_layout

\begin_layout Standard
Every atom has an associated 
\emph on
type
\emph default
, which is itself just another atom.
 Since every atom has a type, and every type is an atom, we have a potential
 infinite regress.
 To avoid this the special 
\emph on
type universe
\emph default
 atom, denoted 
\family typewriter
^TYPE
\family default
, is its own type.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
As has been pointed out, 
\begin_inset Quotes eld
\end_inset

it's turtles all the way down.
\begin_inset Quotes erd
\end_inset

 
\family typewriter
^TYPE
\family default
 is the turtle that stands on its own head.
\end_layout

\end_inset

 The fact that atom 
\begin_inset Formula $a$
\end_inset

 has type 
\begin_inset Formula $T$
\end_inset

 is denoted by joining the atom and its type with a colon: 
\begin_inset Formula $a:T$
\end_inset

.
 The type colon is right associative, so 
\begin_inset Formula $a:B:C$
\end_inset

 denotes 
\begin_inset Formula $a:(B:C)$
\end_inset

.
 In fact, this is the only way the colon can work.
 Since an atom has exactly one type, 
\begin_inset Formula $(a:B):C$
\end_inset

 is effectively meaningless, and generates an error in Elision.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Every atom is an instance of a class extending 
\family typewriter
core.BasicAtom
\family default
.
 All atoms are immutable after construction.
 The type of an atom must be specified at construction time, and can be
 accessed later via the public field 
\family typewriter
theType
\family default
.
 The type universe can be accessed in two ways: 
\family typewriter
core.TypeUniverse
\family default
 is a singleton implementing the type universe, and it can be accessed via
 the alias 
\family typewriter
`^TYPE`
\family default
 provided by the 
\family typewriter
core
\family default
 package.
 Back ticks must be used since 
\family typewriter
^TYPE
\family default
 is not a valid Scala symbol.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Literals
\end_layout

\begin_layout Standard
Elision directly supports several kinds of literals.
 These are indivisible, simple-valued atoms.
\end_layout

\begin_layout Subsection
Symbols
\end_layout

\begin_layout Standard
Symbols start with an underscore or letter, followed by any number of letters,
 digits, and underscores.
 The following are legal symbol literals.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="4">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
A
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
x
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
_21
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Fred21
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Other characters may occur in symbols, but the entire symbol must be enclosed
 in back ticks, which are not themselves part of the symbol.
 Several escape sequences are interpreted; these are listed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Escape-Codes"

\end_inset

.
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Escape-Codes"

\end_inset

Escape Codes
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
f
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Form Feed Character
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
n
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Newline
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
r
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Carriage Return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
t
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tab Character
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
`
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Back tick
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash

\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Double Quotation Mark
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash

\backslash

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Backslash
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset

 Using the back tick notation the following are also legal symbol literals.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="4">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
`1`
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
`$_4`
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
`
\backslash
`Fred
\backslash
``
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
``
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Symbols are created via the 
\family typewriter
core.Literal(sym)
\family default
 method, where 
\family typewriter
sym
\family default
 is a Scala symbol.
\end_layout

\begin_layout Plain Layout
Take care! Scala symbols are automatically converted to Elision 
\emph on
variables
\emph default
, not symbol literals, when used in a context expecting an Elision atom.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Strings
\end_layout

\begin_layout Standard
A string is a sequence of characters enclosed in double quotation marks,
 which are not themselves part of the symbol.
 As with back-tick-quoted symbols, escape codes are interpreted in the string.
 The escape codes are listed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Escape-Codes"

\end_inset

.
 The following are legal string literals.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="4">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
""
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
"Fred"
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
"`21,` she said."
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
"
\backslash
"Yes,
\backslash
" he replied."
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Strings are created via the 
\family typewriter
core.Literal(str)
\family default
 method, where 
\family typewriter
str
\family default
 is a Scala string.
\end_layout

\begin_layout Plain Layout
Scala strings are automatically converted to Elision string literals as
 necessary.
 Thus it is possible to pass 
\family typewriter
"$"
\family default
 to a method expecting an Elision atom.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Numbers
\end_layout

\begin_layout Standard
Numbers may be expressed in binary, octal, decimal, hexadecimal (the 
\emph on
radix
\emph default
).
 Binary numbers are indicated by the prefix 
\family typewriter
0b
\family default
, octal numbers are indicated by a leading 
\family typewriter
0
\family default
, decimal numbers are indicated by a leading non-zero digit, and hexadecimal
 numbers are indicated by the prefix 
\family typewriter
0x
\family default
.
\end_layout

\begin_layout Standard
Floating point numbers are supported in all radices, and are indicated either
 by a decimal point, an exponent, or both.
 The exponent is typically indicated by an 
\family typewriter
e
\family default
, must be an integer, and may be in a different radix.
 Because 
\family typewriter
e
\family default
 is a valid hexadecimal digit, 
\family typewriter
p
\family default
 may also be used to indicate an exponent (and must be for hexadecimal numbers).
 Numbers are 
\emph on
not
\emph default
 case sensitive.
 If the floating point number consists of significand 
\begin_inset Formula $s$
\end_inset

, exponent 
\begin_inset Formula $e$
\end_inset

, and radix 
\begin_inset Formula $r$
\end_inset

, then the number denoted is given by the following equation.
\begin_inset Formula 
\[
s\times r^{e}
\]

\end_inset


\end_layout

\begin_layout Standard
The following are legal number literals.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
-1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
05743645134635
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
-0x232
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
2.5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0b10.1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0x2.8
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
02.4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
21e-6
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0b10101e-0b110
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0x15p-0x6
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
025e-06
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
Keep in mind that the radix of the significand and the exponent must both
 be specified.
\end_layout

\begin_layout Standard
The number undergoes a conversion to place it in a consistent radix.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This conversion takes place during parsing.
\end_layout

\end_inset

 This conversion is performed as follows.
 Let the number be 
\begin_inset Formula $i.f\mathtt{e}e$
\end_inset

, where 
\begin_inset Formula $i$
\end_inset

 is the integer portion of the significand, 
\begin_inset Formula $f$
\end_inset

 is the fractional portion of the significand, and 
\begin_inset Formula $e$
\end_inset

 is the exponent.
 We note that 
\begin_inset Formula $i.f$
\end_inset

 is in one radix, which we denote 
\begin_inset Formula $r$
\end_inset

, and the exponent may be in a different radix.
 If the length of 
\begin_inset Formula $f$
\end_inset

 is 
\begin_inset Formula $|f|$
\end_inset

, then the entire significand is multiplied by 
\begin_inset Formula $r_{s}^{|f|}$
\end_inset

 to convert it to an integer.
 The exponent is then converted to radix 
\begin_inset Formula $r$
\end_inset

, yielding 
\begin_inset Formula $e'$
\end_inset

, and 
\begin_inset Formula $n$
\end_inset

 is subtracted from it.
\begin_inset Formula 
\[
n=i.f\mathtt{e}e=(i.f)r^{|f|}\mathtt{e}e'
\]

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Integers are created via the 
\family typewriter
core.Literal(i)
\family default
 method, where 
\family typewriter
i
\family default
 is a Scala 
\family typewriter
BigInt
\family default
.
 Floating point numbers can be created via the 
\family typewriter
core.Literal(FLOAT,sig,exp,rad)
\family default
 method, where 
\family typewriter
sig
\family default
 is the significand (a Scala 
\family typewriter
BigInt
\family default
), 
\family typewriter
exp
\family default
 is the exponent (a Scala 
\family typewriter
Int
\family default
), and 
\family typewriter
rad
\family default
 is the radix (one of 2, 8, 10, or 16).
\end_layout

\begin_layout Plain Layout
Scala 
\family typewriter
Int
\family default
 and 
\family typewriter
BigInt
\family default
 are automatically converted to Elision integer literals as necessary.
 Thus it is possible to pass 
\family typewriter
17
\family default
 to a method expecting an Elision atom.
\end_layout

\begin_layout Plain Layout
If you have a floating point literal, you can obtain its value as a Scala
 float with 
\family typewriter
toFloat
\family default
 and as a Scala double with 
\family typewriter
toDouble
\family default
.
 You can also convert it to radix two using 
\family typewriter
toBinary
\family default
.
 Because this changes the base of a floating point number you may lose precision.
\end_layout

\begin_layout Plain Layout
At present Elision does not support the positive or negative infinity or
 the signaling or quiet NaN.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Booleans
\end_layout

\begin_layout Standard
Boolean literals come in two forms: 
\family typewriter
true
\family default
 and 
\family typewriter
false
\family default
.
 Both have the type 
\family typewriter
BOOLEAN
\family default
.
 If you want an Elision symbol named 
\family typewriter
true
\family default
 or 
\family typewriter
false
\family default
, you must override the type, and write 
\family typewriter
true:SYMBOL
\family default
, for instance.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
The Boolean literals can be obtained as 
\family typewriter
Literal.TRUE
\family default
 and 
\family typewriter
Literal.FALSE
\family default
.
 Scala Booleans are automatically converted to Elision Boolean literals
 as necessary.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Special Symbols
\end_layout

\begin_layout Standard
Certain symbols are interpreted differently from others.
 Three have already been discussed: 
\family typewriter
^TYPE
\family default
 denoting the type universe, 
\family typewriter
true
\family default
, and 
\family typewriter
false
\family default
.
 Others denote named root types.
 A 
\emph on
root type
\emph default
 is an atom whose type is 
\family typewriter
^TYPE
\family default
.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Special-Root-Type"

\end_inset

 lists the named root types declared by the current system.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Special-Root-Type"

\end_inset

Special Root Type Symbols
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Elision Symbol
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interpretation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ANY
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The wildcard.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
BINDING
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The root type for all bindings.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
BOOLEAN
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The root type for all Booleans.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
FLOAT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The root type for all floating point numbers.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
INTEGER
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The root type for all integer numbers.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
OPTYPE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A root type for indicating that a symbol denotes an operator.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
STRATEGY
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The root type for all strategies and rewrite rules.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
STRING
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The root type for all strings.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
SYMBOL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The root type for all symbols.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The special atom 
\family typewriter
ANY
\family default
 matches any atom, and any atom matches it, so it can be treated as a wildcard
 during matching.
 It is also the assumed type of otherwise untyped atoms.
\end_layout

\begin_layout Standard
Untyped symbols have the type 
\family typewriter
SYMBOL
\family default
, except for the special symbol 
\family typewriter
Nothing
\family default
 that has type 
\family typewriter
ANY
\family default
.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
All the symbols listed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Special-Root-Type"

\end_inset

 are also Scala objects that extend 
\family typewriter
core.NamedRootType
\family default
.
 They can be used directly, so 
\family typewriter
SYMBOL
\family default
 is a Scala value denoting the Elision 
\family typewriter
SYMBOL
\family default
 type.
 To get the special symbol 
\family typewriter
Nothing
\family default
, use 
\family typewriter
core.Literal.NOTHING
\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Variables
\end_layout

\begin_layout Standard
Variables are indicated by a leading dollar sign followed by the variable
 name, which is a symbol.
 The following are legal variables.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="4">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
$x
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
$_21
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
$`1`
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
$`$_4`
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Variables are looked up by name, but matched by 
\emph on
both
\emph default
 name and type.
 This means that you should never use the same variable name with different
 types in a single atom, as it will break matching in unusual ways.
 If no type is specified for a variable, Elision assigns it the special
 wildcard 
\family typewriter
ANY
\family default
.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Variables are created using 
\family typewriter
core.Variable(typ,name)
\family default
, where 
\family typewriter
typ
\family default
 is the variable type, and 
\family typewriter
name
\family default
 is the variable name.
 Thus the Elision variable 
\family typewriter
$x:INTEGER
\family default
 can be created with 
\family typewriter
Variable(INTEGER,"x")
\family default
.
 Scala symbols are also automatically converted to variables of type 
\family typewriter
ANY
\family default
, so it is possible to pass a Scala symbol to methods expecting an atom.
 Thus 
\family typewriter
$x:ANY
\family default
 can also be written (depending on context) as 
\family typewriter
'x
\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Lambdas"

\end_inset

Lambdas
\end_layout

\begin_layout Standard
A lambda expression denotes a function with a single parameter, and consists
 of a variable called the 
\emph on
lambda parameter
\emph default
 and an atom called the 
\emph on
body
\emph default
.
 The lambda is 
\emph on
evaluated
\emph default
 (or 
\emph on
curried
\emph default
) by applying it to another atom, called the 
\emph on
argument
\emph default
, and then replacing instances of the lambda parameter in the body with
 the argument.
 This is all much simpler than it sounds.
\end_layout

\begin_layout Standard
Lambdas are introduced by a backslash (
\family typewriter

\backslash

\family default
), the parameter (a variable), a dot (
\family typewriter
.
\family default
), and the body (an atom).
 The following is a lambda that denotes a constant function whose value
 is 7 no matter what argument is provided.
\end_layout

\begin_layout LyX-Code

\backslash
$x.7
\end_layout

\begin_layout Standard
The following denotes the identity function that returns the atom it is
 applied to.
\begin_inset Foot
status open

\begin_layout Plain Layout
This is sometimes called the 
\emph on
I combinator
\emph default
.
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\backslash
$x.$x
\end_layout

\begin_layout Standard
The following is a lambda that creates constant functions.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This also has a catchy name: it is the 
\emph on
K combinator
\emph default
.
\end_layout

\end_inset

 When applied to an argument, the result is a function that always returns
 the argument.
\end_layout

\begin_layout LyX-Code

\backslash
$x.
\backslash
$y.$x
\end_layout

\begin_layout Standard
To apply the lambda to an atom, join the lambda and the atom with a dot
 (
\family typewriter
.
\family default
).
 The lambda dot binds more tightly than the application dot.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Lambdas"

\end_inset

 shows some examples of lambda applications and the results.
 The parentheses around the 7 in the first entry are required to prevent
 the system from seeing 7.12 as a floating point number.
\end_layout

\begin_layout Standard
Consider the last item in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Lambdas"

\end_inset

.
 We move through this step-by-step to show what is going on here.
 First, let's parenthesize this to better see the pieces: 
\family typewriter
(
\backslash
$x.(
\backslash
$y.$x)).12
\family default
.
 Now we see that we have a lambda expression of the form 
\family typewriter

\backslash
$x.
\family default

\begin_inset Formula $b$
\end_inset


\family typewriter
.12
\family default
, where 
\begin_inset Formula $b$
\end_inset

 is the lambda body.
 This says to replace 
\family typewriter
$x
\family default
 with 
\family typewriter
12
\family default
 in the body.
 Replacing 
\family typewriter
$x
\family default
 with 
\family typewriter
12
\family default
 in the body (
\family typewriter
$y.$x
\family default
) gives 
\family typewriter
$y.12
\family default
, which is the answer.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Lambdas"

\end_inset

Lambdas
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lambda Expression
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$x.(7).12
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$x.$x.12
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$x.
\backslash
$y.$x.12
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$y.12
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you enter 
\family typewriter

\backslash
$x.
\backslash
$y.$x.12
\family default
 at the Elision prompt, you will 
\emph on
not
\emph default
 see 
\family typewriter

\backslash
$y.12
\family default
.
 What you 
\emph on
will
\emph default
 see is 
\family typewriter

\backslash
$`:1`.12
\family default
.
 The 
\family typewriter
$y
\family default
 has been replaced with the funny symbol 
\family typewriter
$`:1`
\family default
.
 This symbol is a DeBruijn index, and it is used to prevent lambdas from
 
\begin_inset Quotes eld
\end_inset

capturing
\begin_inset Quotes erd
\end_inset

 variables.
 In practice you should not need to worry about DeBruijn indices; the system
 uses them when appropriate and keeps track of the details for you.
 If you are curious, please see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:De-Bruijn-Indices"

\end_inset

.
\end_layout

\begin_layout Standard
A lambda parameter is 
\emph on
matched
\emph default
 against the argument, and the result is used to 
\emph on
rewrite
\emph default
 the body.
 This is all explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Matching-and-Rewriting"

\end_inset

, but in practice it means that if you specify the type of the parameter,
 then Elision will enforce this.
 Thus the lambda expression 
\family typewriter

\backslash
$x:INTEGER.$x.7
\family default
 will succeed with the value 7, while the lambda expression 
\family typewriter

\backslash
$x:INTEGER.$x."Fred"
\family default
 will fail with an error.
 This also means that the type of an atom can be extracted using a lambda.
 The following lambda will extract the type of any atom it is applied to.
\end_layout

\begin_layout LyX-Code

\backslash
$x:$T.$T
\end_layout

\begin_layout Standard
Thus the expression 
\family typewriter

\backslash
$x:$T.$T."Fred"
\family default
 evaluates to 
\family typewriter
STRING
\family default
.
\end_layout

\begin_layout Standard
Because the applicative dot binds right to left, multiple parameter lambda
 expressions must be parenthesized when applied, as with the following.
\end_layout

\begin_layout LyX-Code

\backslash
$first.(
\backslash
$second.%($first,$second).2).1
\end_layout

\begin_layout Standard
This evaluates to the atom list 
\family typewriter
%(1,2)
\family default
.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
To create a lambda use 
\family typewriter
core.Lambda(param,body)
\family default
, where 
\family typewriter
param
\family default
 is the lambda parameter and 
\family typewriter
body
\family default
 is the lambda body.
 To apply a lambda to an argument, use 
\family typewriter
core.Apply(lambda,arg)
\family default
, where 
\family typewriter
lambda
\family default
 is the lambda expression and 
\family typewriter
arg
\family default
 is the argument.
 The following shows how several lambda expressions can be created in Scala.
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lambda Expression
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Scala Code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$x.7
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Lambda('x,7)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$x.$x
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Lambda('x,'x)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$x.
\backslash
$y.$x
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Lambda('x,Lambda('y,'x))
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$x:INTEGER.$x.7
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Apply(Lambda(Variable(INTEGER,"x"),'x),7)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$x:$T.$T."Fred"
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Apply(Lambda(Variable('T,"x"),'T),"Fred")
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Operators"

\end_inset

Operators
\end_layout

\begin_layout Standard
In general, operators denote mappings on atoms.
 However, Elision manipulates operators symbolically, so they should be
 regarded as mathematical functions, and not necessarily in the computer
 language sense.
 Elision supports the following kinds of operator.
\end_layout

\begin_layout Itemize
A 
\emph on
symbolic
\emph default
 operator is simply an atom that is manipulated by the system through rewriting.
 A Scala 
\emph on
closure
\emph default
 can be provided to construct instances of the operator, making the operator
 a 
\emph on
native
\emph default
 operator.
 This is how arithmetic operators, for example, are implemented.
\end_layout

\begin_layout Itemize
An 
\emph on
immediate
\emph default
 operator denotes a kind of macro.
 Once the parameters are bound to arguments, this binding is used to rewrite
 a provided body, which is the result of the operator application.
\end_layout

\begin_layout Section
Operator Prototypes
\end_layout

\begin_layout Standard
Prior to use, operators must be defined.
 All operator definitions must have a 
\emph on
prototype
\emph default
 that specifies the operator name, parameters, and type information.
 Symbolic and native operator definitions must provide the operator 
\emph on
properties
\emph default
, if any.
 Immediate operator definitions must provide a 
\emph on
body
\emph default
.
\end_layout

\begin_layout Standard
Operator prototypes specify the operator name as a symbol, and give a comma-sepa
rated list of named parameters in parentheses.
 Each parameter is a variable whose type may be specified (otherwise it
 is 
\family typewriter
ANY
\family default
).
 Following the closing parenthesis the type of the fully-applied operator
 may be given (if not, it, too, is 
\family typewriter
ANY
\family default
).
 For instance, if the operator 
\family typewriter
foo
\family default
 takes two integer arguments and returns an integer value, we would write
 its prototype as: 
\family typewriter
foo($x: INTEGER, $y: INTEGER): INTEGER
\family default
.
 Types may be variables, so you can write 
\family typewriter
join($x:$T, $y:$T):$T
\family default
 to indicate an operator that takes two arguments of the same type and evaluates
 to the same type as the arguments.
\end_layout

\begin_layout Standard
Operator prototypes are not, by themselves, atoms, and they cannot be specified
 using the alternate notation for operator application (the applicative
 dot to be discussed later).
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Operator prototypes are created with 
\family typewriter
core.OperatorPrototype
\family default
.
 Pass the name, a vector of 
\family typewriter
core.Variable
\family default
 instances as parameters, and the type.
 At present you must pass a list as the last argument, but it may be empty.
 The following defines the 
\family typewriter
foo
\family default
 prototype given above.
\end_layout

\begin_layout LyX-Code
OperatorPrototype("foo",
\end_layout

\begin_layout LyX-Code
  Vector(Variable(INTEGER,"x"), Variable(INTEGER,"y")),
\end_layout

\begin_layout LyX-Code
  INTEGER, List())
\end_layout

\begin_layout Plain Layout
Another way to define an operator prototype is to use the 
\family typewriter
core.Proto
\family default
 constructor.
 To use this pass the name, the type of the fully-applied operator, and
 then the parameters, with each parameter as a pair of the form (name, type).
 This constructor takes a variable length parameter list.
 The following is equivalent to the above declaration.
\end_layout

\begin_layout LyX-Code
Proto("foo", INTEGER,
\end_layout

\begin_layout LyX-Code
  ("x",INTEGER), ("y",INTEGER))
\end_layout

\end_inset


\end_layout

\begin_layout Section
Operator Properties
\end_layout

\begin_layout Standard
Both symbolic and native operator definitions may provide a comma-separated
 list of operator properties, introduced with the keyword 
\family typewriter
is
\family default
.
 The allowable properties are the following.
\end_layout

\begin_layout Itemize

\family typewriter
associative
\family default
: The operator is associative, meaning that the arguments can be arbitrarily
 grouped, but not necessarily re-ordered.
\end_layout

\begin_layout Itemize

\family typewriter
commutative
\family default
: The operator is commutative, meaning that the arguments can be arbitrarily
 re-ordered, but not necessarily re-grouped.
\end_layout

\begin_layout Itemize

\family typewriter
idempotent
\family default
: The operator is idempotent, meaning that repeated arguments can be replaced
 with a single instance.
\end_layout

\begin_layout Itemize

\family typewriter
identity A
\family default
: The operator has an identity, given by the atom 
\family typewriter
A
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
absorber A
\family default
: The operator has an absorber, given by the atom 
\family typewriter
A
\family default
.
\end_layout

\begin_layout Standard
For example, the property statement for addition is: 
\family typewriter
is associative, commutative, identity 0
\family default
.
 The property statement for multiplication is: 
\family typewriter
is associative, commutative, identity 1, absorber 0
\family default
.
 The property statement for Boolean logical or is: 
\family typewriter
is associative, commutative, idempotent, identity false, absorber true
\family default
.
\end_layout

\begin_layout Standard
Each property is described in more detail in the following subsections.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Operator properties are specified by 
\family typewriter
core.AlgProp
\family default
.
 This class can be used directly, but it is typically easier to use its
 extensions: 
\family typewriter
Associative
\family default
, 
\family typewriter
Commutative
\family default
, 
\family typewriter
Idempotent
\family default
, 
\family typewriter
Absorber(atom)
\family default
, and 
\family typewriter
Identity(atom)
\family default
.
 The first three can be negated by prefixing them with an exclamation mark,
 and the last two take an atom.
 Join these with 
\family typewriter
and
\family default
.
 The following builds the properties for addition, given above.
\end_layout

\begin_layout LyX-Code
Associative and Commutative and Identity(0)
\end_layout

\begin_layout Plain Layout
There is also an extension 
\family typewriter
NoProps
\family default
 that indicates no properties.
 This is sometimes useful if you don't want to specify any properties.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Associativity
\end_layout

\begin_layout Standard
An associative operator 
\begin_inset Formula $f$
\end_inset

 can have its arguments grouped arbitrarily.
 Thus 
\begin_inset Formula $f(a,b,c)=f(f(a,b),c)=f(a,f(b,c))$
\end_inset

.
 Note that any argument could be replaced with another application, so any
 number of arguments is possible.
\end_layout

\begin_layout Standard
Suppose we define operator 
\begin_inset Formula $f$
\end_inset

 to have prototype 
\begin_inset Formula $f(a:A,b:B):F$
\end_inset

.
 Since we can replace either 
\begin_inset Formula $a$
\end_inset

 or 
\begin_inset Formula $b$
\end_inset

 with another application of 
\begin_inset Formula $f$
\end_inset

, we conclude that 
\begin_inset Formula $F\subseteq A$
\end_inset

 and 
\begin_inset Formula $F\subseteq B$
\end_inset

.
 We further note the following, by associativity.
\begin_inset Formula 
\[
f(f(c:A,d:B),b:B)=f(c:A,f(d:B,b:B))
\]

\end_inset

Thus it must be the case that 
\begin_inset Formula $B\subseteq A$
\end_inset

.
 By a similar argument we conclude that 
\begin_inset Formula $A\subseteq B$
\end_inset

, and thus 
\begin_inset Formula $A=B$
\end_inset

.
 For these reasons we require that all parameters of an associative operator
 have the same type, and that the parameter type must be the same as the
 overall operator type.
 Thus the following associative operator prototypes are rejected by the
 system.
\end_layout

\begin_layout Itemize

\family typewriter
bad1($x: INTEGER, $y: STRING): INTEGER
\family default

\begin_inset Newline newline
\end_inset

The parameters do not have the same type.
\end_layout

\begin_layout Itemize

\family typewriter
bad2($x: INTEGER, $y: INTEGER): STRING
\family default

\begin_inset Newline newline
\end_inset

The operator type is not the same as the parameter type.
\end_layout

\begin_layout Standard
An associative operator must declare 
\emph on
exactly
\emph default
 two parameters.
 The following is an example.
\end_layout

\begin_layout LyX-Code
add($x: INTEGER, $y: INTEGER): INTEGER
\end_layout

\begin_layout Standard
Associativity is 
\emph on
required
\emph default
 by idempotency, any identity, and any absorber.
\end_layout

\begin_layout Subsection
Commutativity
\end_layout

\begin_layout Standard
A commutative (or abelian) operator 
\begin_inset Formula $f$
\end_inset

 can have its arguments re-ordered arbitrarily.
 Thus 
\begin_inset Formula $f(a,b)=f(b,a)$
\end_inset

.
 If we provide type information, we see the following: 
\begin_inset Formula $f(a:A,b:B)=f(b:B,a:A)$
\end_inset

, and we conclude that 
\begin_inset Formula $A\subseteq B$
\end_inset

 and 
\begin_inset Formula $B\subseteq A$
\end_inset

, or 
\begin_inset Formula $A=B$
\end_inset

.
 We thus require that all arguments to a commutative operator have the same
 type, though this need not be the type of the fully-applied operator.
 The following commutative operator prototype is rejected by the system.
\end_layout

\begin_layout Itemize

\family typewriter
bad($x: INTEGER, $y: STRING): STRING
\family default

\begin_inset Newline newline
\end_inset

The parameters do not have the same type.
\end_layout

\begin_layout Standard
A commutative operator must declare 
\emph on
at least
\emph default
 two parameters.
\end_layout

\begin_layout Subsection
Idempotency
\end_layout

\begin_layout Standard
An idempotent operator 
\begin_inset Formula $f$
\end_inset

 has the property that 
\begin_inset Formula $f(a,a)=f(a)$
\end_inset

, so repeated arguments are discarded.
 Because the length of the argument list can change, idempotent operators
 are required to be associative.
 An example of an idempotent operator is the Boolean inclusive 
\emph on
or
\emph default
, since 
\begin_inset Formula $\mbox{or}(x,y,x)=\mbox{or}(x,y)$
\end_inset

.
 Idempotency imposes no additional restrictions on an operator beyond those
 imposed by associativity, which is required.
\end_layout

\begin_layout Standard
As an example, we implement multisets and sets using symbolic operators.
 A 
\emph on
multiset
\emph default
 allows repeated elements to be present.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> {operator mset($x,$y) is associative, commutative}
\end_layout

\begin_layout Plain Layout

e> mset(7, fred, "James", blue, 7, blue)
\end_layout

\begin_layout Plain Layout

$repl18 = mset(7, fred:SYMBOL, "James", blue:SYMBOL, 7, blue:SYMBOL)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A 
\emph on
set
\emph default
 does not allow repeated elements.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> {operator set($x,$y) is associative, commutative, idempotent}
\end_layout

\begin_layout Plain Layout

e> set(7, fred, "James", blue, 7, blue)
\end_layout

\begin_layout Plain Layout

$repl19 = set(7, fred:SYMBOL, "James", blue:SYMBOL)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Including idempotency in the list of properties allows a simple implementation
 of sets.
 Examples of idempotent operators are the logical 
\emph on
or
\emph default
 and 
\emph on
and
\emph default
.
\end_layout

\begin_layout Subsection
Identity
\end_layout

\begin_layout Standard
An operator 
\begin_inset Formula $f$
\end_inset

 can have an associated named identity element 
\begin_inset Formula $e$
\end_inset

, with the property that 
\begin_inset Formula $f(x,e)=f(e,x)=f(x)=x$
\end_inset

.
 Instances of a named identity are discarded from the argument list.
 Because the length of the argument list can change, only associative operators
 can have a named identity.
\end_layout

\begin_layout Standard
Named identity elements include 
\emph on
zero
\emph default
 for addition, 
\emph on
one
\emph default
 for multiplication, 
\emph on
false
\emph default
 for Boolean inclusive 
\emph on
or
\emph default
, and 
\emph on
true
\emph default
 for Boolean 
\emph on
and
\emph default
.
\end_layout

\begin_layout Standard
Further, 
\begin_inset Formula $f()$
\end_inset

 is regarded as an alternate name for a named identity 
\begin_inset Formula $e$
\end_inset

.
\end_layout

\begin_layout Subsection
Absorber
\end_layout

\begin_layout Standard
An operator 
\begin_inset Formula $f$
\end_inset

 can have an associated absorber element 
\begin_inset Formula $z$
\end_inset

, with the property that 
\begin_inset Formula $f(x,z)=f(z,x)=z$
\end_inset

.
 If an absorber is present in the argument list then the entire operator
 application is reduced to the absorber.
 Elision currently requires that operators with absorbers be associative,
 though this is not essential for any mathematical reason.
\end_layout

\begin_layout Standard
Absorber elements include zero for multiplication, true for Boolean inclusive
 or, and false for Boolean and.
\end_layout

\begin_layout Section
Operator Declarations
\end_layout

\begin_layout Standard
One declares a symbolic operator by giving the prototype and properties
 in a complete declaration, as follows.
\end_layout

\begin_layout LyX-Code
{ operator or($p: BOOLEAN, $q: BOOLEAN): BOOLEAN
\end_layout

\begin_layout LyX-Code
  is associative, commutative, idempotent,
\end_layout

\begin_layout LyX-Code
     identity false, absorber true }
\end_layout

\begin_layout Standard
An immediate operator declaration provides a prototype and a body, but no
 properties, as the properties are implicit in the declared body.
 A simple example is the 
\family typewriter
typeof
\family default
 operator that extracts and returns the type of its argument.
\end_layout

\begin_layout LyX-Code
{ operator typeof($x:$T:$U):$U = $T }
\end_layout

\begin_layout Standard
All these declarations are used when an operator application is 
\emph on
constructed
\emph default
, meaning when the operator is applied to an argument list.
 In the case of symbolic operators the argument list is processed based
 on the properties.
 If the operator has a closure, processing the argument list happens 
\emph on
prior
\emph default
 to invoking the closure.
 If the operator has an absorber or identity, the closure might not be invoked
 at all.
\end_layout

\begin_layout Standard
Immediate operators are best regarded as a way to specify an alternate name
 for another operator, like a macro.
\end_layout

\begin_layout LyX-Code
{ operator `+`($x: INTEGER, $y: INTEGER): INTEGER = add($x,$y) }
\end_layout

\begin_layout Standard
Note that there is no way to specify properties for an immediate operator
 definition, and thus these cannot take variable length argument lists.
\end_layout

\begin_layout Standard
The following are some examples of operator construction.
\end_layout

\begin_layout Itemize

\family typewriter
or($x,or($y,$z))
\family default
 becomes 
\family typewriter
or($x,$y,$z)
\family default
 because associative applications are 
\begin_inset Quotes eld
\end_inset

flattened.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
add(5,0,2)
\family default
 becomes 
\family typewriter
add(5,2)
\family default
 because identities are discarded.
\end_layout

\begin_layout Itemize

\family typewriter
or(true,false,$x)
\family default
 becomes 
\family typewriter
true
\family default
 because 
\family typewriter
true
\family default
 is an absorber.
\end_layout

\begin_layout Itemize

\family typewriter
add(0,0,0)
\family default
 becomes 
\family typewriter
0
\family default
 because discarding identities leaves 
\family typewriter
add()
\family default
, which is equal to the identity 
\family typewriter
0
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
typeof(true)
\family default
 becomes 
\family typewriter
BOOLEAN
\family default
 because the immediate definition is applied at construction time.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
To create a definition of a symbolic operator, use
\end_layout

\begin_layout Itemize

\family typewriter
core.SymbolicOperatorDefinition(proto,props)
\end_layout

\begin_layout Plain Layout
where 
\family typewriter
proto
\family default
 is the operator prototype and 
\family typewriter
props
\family default
 is the operator properties.
 The following code creates the two examples given previously (the 
\family typewriter
or
\family default
 and 
\family typewriter
add
\family default
 operators).
\end_layout

\begin_layout LyX-Code
import sjp.elision.core._
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
// Make the Boolean inclusive or operator definition.
\end_layout

\begin_layout LyX-Code
val orProto = Proto("or", BOOLEAN, ("P",BOOLEAN), ("Q",BOOLEAN))
\end_layout

\begin_layout LyX-Code
val orProps = Associative and Commutative and Idempotent and
\end_layout

\begin_layout LyX-Code
                    Absorber(false) and Identity(true)
\end_layout

\begin_layout LyX-Code
val orOp = SymbolicOperatorDefinition(orProto, orProps)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
// Make the integer add operator definition.
\end_layout

\begin_layout LyX-Code
val addProto = Proto("add", INTEGER, ("x",INTEGER), ("y",INTEGER))
\end_layout

\begin_layout LyX-Code
val addProps = Associative and Commutative and Identity(0)
\end_layout

\begin_layout LyX-Code
val addOp = SymbolicOperatorDefinition(addProto, addProps)
\end_layout

\begin_layout Plain Layout
To create a definition of an immediate operator, use 
\family typewriter
core.ImmediateOperatorDefinition(proto, body)
\family default
, where 
\family typewriter
proto
\family default
 is the operator prototype and 
\family typewriter
body
\family default
 is the immediate operator body.
 The following code creates the 
\family typewriter
typeof
\family default
 example given previously.
 This will use some constructors not previously discussed, and uses the
 fact that Scala symbols are interpreted as variables of type 
\family typewriter
ANY
\family default
, so 
\family typewriter
'U
\family default
 is shorthand for 
\family typewriter
Variable(ANY,"U")
\family default
.
\end_layout

\begin_layout LyX-Code
import sjp.elision.core._
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
// Make the typeof operator definition.
\end_layout

\begin_layout LyX-Code
val typeofProto = Proto("typeof", 'U, ("x", Variable('U, "T")))
\end_layout

\begin_layout LyX-Code
val typeofOp = ImmediateOperatorDefinition(typeofProto, 'T)
\end_layout

\begin_layout Plain Layout
Operator definitions 
\emph on
are
\emph default
 atoms, so they could be matched and rewritten.
 In practice, this is not currently supported, primarily due to the fact
 that their components (the prototype and properties objects) are not atoms.
 This may change in a future version of Elision.
\end_layout

\begin_layout Plain Layout
Operator definitions should be installed in an instance of 
\family typewriter
core.OperatorLibrary
\family default
, typically found in an instance of 
\family typewriter
core.Context
\family default
.
 A context is automatically created and provided by the REPL, so if you
 are interacting with the REPL you do not need to worry about this.
 Contexts and operator libraries are explained in more detail in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Contexts"

\end_inset

.
 If you have a context instance, you can install a new operator by first
 getting the operator library from the context with 
\family typewriter
operatorLibrary
\family default
, and then invoking 
\family typewriter
add(opdef)
\family default
 on the instance, where 
\family typewriter
opdef
\family default
 is the operator definition.
\end_layout

\begin_layout Plain Layout
For instance, if 
\family typewriter
context
\family default
 is an instance of 
\family typewriter
core.Context
\family default
, then the operators defined above can be installed with the following lines
 of code.
\end_layout

\begin_layout LyX-Code
// Install definitions.
\end_layout

\begin_layout LyX-Code
context.operatorLibrary.add(orOp)
\end_layout

\begin_layout LyX-Code
context.operatorLibrary.add(addOp)
\end_layout

\begin_layout LyX-Code
context.operatorLibrary.add(typeofOp)
\end_layout

\begin_layout Plain Layout
The operator library is also where you register a closure for a symbolic
 operator.
 The closure must take a triple, consisting of the operator, the argument
 list as an instance of 
\family typewriter
core.AtomList
\family default
, and an optional instance of 
\family typewriter
core.Bindings
\family default
.
 The bindings are the result of matching the operator parameters against
 the arguments, and may be indispensable in some cases.
 The closure must then return an atom.
 Matching, binding, and rewriting are all explained in more detail in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Matching-and-Rewriting"

\end_inset

.
 The following actually implements addition as a symbolic operator with
 a native constructor, though it uses some methods not explained just yet.
\end_layout

\begin_layout LyX-Code
// Define add as a symbolic operator.
\end_layout

\begin_layout LyX-Code
val addOp = SymbolicOperatorDefinition(
\end_layout

\begin_layout LyX-Code
  Proto("add", INTEGER, ("x", INTEGER), ("y", INTEGER)),
\end_layout

\begin_layout LyX-Code
  Associative and Commutative and Identity(0))
\end_layout

\begin_layout LyX-Code
// Create a closure to perform the addition.
\end_layout

\begin_layout LyX-Code
def doaddOp(op: Operator, args: AtomList,
\end_layout

\begin_layout LyX-Code
    binds: Bindings) = {
\end_layout

\begin_layout LyX-Code
  // Accumulate the integer literals found.
\end_layout

\begin_layout LyX-Code
  var lits: BigInt = 0
\end_layout

\begin_layout LyX-Code
  // Accumulate other atoms found.
\end_layout

\begin_layout LyX-Code
  var other = IndexedSeq[BasicAtom]()
\end_layout

\begin_layout LyX-Code
  // Traverse the list and divide the atoms.
\end_layout

\begin_layout LyX-Code
  args.atoms.foreach {
\end_layout

\begin_layout LyX-Code
    x => x match {
\end_layout

\begin_layout LyX-Code
      case IntegerLiteral(_, value) => lits += value
\end_layout

\begin_layout LyX-Code
      case _ => other :+= x
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
  // Now add the accumulated literals to the list.
\end_layout

\begin_layout LyX-Code
  other :+= Literal(INTEGER, lits)
\end_layout

\begin_layout LyX-Code
  // Construct and return the new operator application.
\end_layout

\begin_layout LyX-Code
  Apply(op, AtomList(other), true)
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
// Register the operator and its handler.
\end_layout

\begin_layout LyX-Code
context.operatorLibrary.add(addOp)
\end_layout

\begin_layout LyX-Code
context.operatorLibrary.register("add", doaddOp)
\end_layout

\begin_layout Plain Layout
It is the job of the 
\family typewriter
core.Apply
\family default
 class to create operator (and other) applications.
 While this is explained in more detail in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:The-Applicative-Dot"

\end_inset

, we note some important things here.
\end_layout

\begin_layout Plain Layout
First, 
\family typewriter
core.Apply
\family default
 understands how to use the operator prototype to process absorbers and
 identities, etc., and this processing is performed 
\emph on
first
\emph default
.
 Thus it is possible to attempt to construct a symbolic operator application
 with a native constructor and never have the native constructor get invoked.
 For instance, 
\family typewriter
add(0)
\family default
 is immediately rewritten to 
\family typewriter
0
\family default
, and the native constructor is never invoked.
\end_layout

\begin_layout Plain Layout
Second, the native constructor may 
\emph on
re
\emph default
-invoke 
\family typewriter
core.Apply
\family default
, as is done in the handler for 
\family typewriter
add
\family default
.
 This can simplify the native constructor since it does not have to worry
 about identities, etc.
 In the 
\family typewriter
add
\family default
 constructor, the result for 
\family typewriter
lits
\family default
 might be zero.
 By re-invoking 
\family typewriter
core.Apply
\family default
 it will get correctly processed.
\end_layout

\begin_layout Plain Layout
This second case leads to a potential problem.
 The 
\family typewriter
core.Apply
\family default
 processing will invoke the native constructor, and our native constructor
 invokes 
\family typewriter
core.Apply
\family default
.
 To prevent this recursion we pass 
\family typewriter
true
\family default
 as the optional third argument to 
\family typewriter
core.Apply
\family default
 to prevent re-invoking the native constructor.
 It is thus possible to write a native constructor that does some processing,
 lets itself get re-invoked, does more processing, etc., until it finally
 terminates the cycle.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Operator Applications
\end_layout

\begin_layout Standard
Once an operator is defined, it can be applied to arguments.
 If the arguments match the parameters then the operator is fully applied
 and a new atom is created called an 
\emph on
apply
\emph default
.
 Assuming the 
\family typewriter
and
\family default
, 
\family typewriter
or
\family default
, and 
\family typewriter
typeof
\family default
 operators given in the previous section are defined, the following are
 all valid applications.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="4">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
add(4,5,$x)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
or($x,false)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
typeof(6)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
typeof(add($x,9))
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Because of the properties of the 
\family typewriter
or
\family default
 operator, the second term 
\family typewriter
or($x,false)
\family default
 immediately reduces to 
\family typewriter
$x
\family default
.
 The last two reduce immediately to 
\family typewriter
INTEGER
\family default
.
\end_layout

\begin_layout Standard
Operator applications can be nested, provided types match.
 The following is an example.
\end_layout

\begin_layout LyX-Code
or(equal(add($x,21),64),equal(add($y,17),32))
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Operator application is explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:The-Applicative-Dot"

\end_inset

.
\end_layout

\begin_layout Plain Layout
Before an operator can be applied, you must get an instance of that operator.
 If you have installed the operator definition in an operator library, you
 can retrieve it via the 
\family typewriter
get(name)
\family default
 method of 
\family typewriter
core.OperatorLibrary
\family default
, where 
\family typewriter
name
\family default
 is the operator name.
 This will return an instance of 
\family typewriter
core.Operator
\family default
.
 The operator definition, and thus the prototype and properties (or body
 depending on the kind of definition), can be obtained from the operator
 instance.
 Alternately, you can use the 
\family typewriter
apply
\family default
 method of 
\family typewriter
core.OperatorLibrary
\family default
 if you are sure the operator exists.
 If the operator does not exist, this method will throw an exception.
 The following are two ways to obtain the 
\family typewriter
add
\family default
 operator, given a context instance 
\family typewriter
context
\family default
.
\end_layout

\begin_layout LyX-Code
context.operatorLibrary.get("add") match {
\end_layout

\begin_layout LyX-Code
  case Some(op) => // Do something with the operator op.
\end_layout

\begin_layout LyX-Code
  case None => // The operator is not known!
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
// The following throws an UndefinedOperatorException if
\end_layout

\begin_layout LyX-Code
// add is not known.
\end_layout

\begin_layout LyX-Code
context.operatorLibrary("add")
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:The-Applicative-Dot"

\end_inset

The Applicative Dot
\end_layout

\begin_layout Standard
Operator applications can be written in two forms: 
\family typewriter
add(4,5,$x)
\family default
 and 
\family typewriter
add.%(4,5,$x)
\family default
.
 This second form uses the 
\emph on
applicative dot
\emph default
 and an 
\emph on
atom list
\emph default
 to apply an operator to arguments.
 The two forms are equivalent; they are alternative ways to represent the
 same atom.
 The first form is actually a shorthand notation for the second.
 Both operators and atom lists are themselves atoms, and can be manipulated
 by the system.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Matching-and-Rewriting"

\end_inset

 the applicative dot notation will turn out to be very useful.
\end_layout

\begin_layout Standard
While operators are atoms, if you just evaluate 
\family typewriter
add
\family default
 Elision will interpret this as a symbol of type 
\family typewriter
SYMBOL
\family default
.
 To force Elision to look this operator up, write 
\family typewriter
add:OPTYPE
\family default
.
 The 
\family typewriter
OPTYPE
\family default
 is not actually the type of the operator, but just a hint to force the
 Elision parser to look up the operator in the parser's context.
\end_layout

\begin_layout Standard
The actual type of an operator is a 
\emph on
mapping
\emph default
 from some domain to some range, deduced from the operator prototype.
 This can be obtained using the lambda trick presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Lambdas"

\end_inset

.
 With 
\family typewriter
add
\family default
 defined in the current REPL session, try the following.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> 
\backslash
$x:$T.$T.add:OPTYPE
\end_layout

\begin_layout Plain Layout

repl0 = MAP(xx(INTEGER, INTEGER), INTEGER)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The type for the 
\family typewriter
add
\family default
 operator is a mapping from pairs of integers to integers, and not 
\family typewriter
OPTYPE
\family default
.
 The above expression parses correctly because the applicative dot binds
 the most weakly of all connectors; more weakly than the lambda dot, for
 instance, which binds more weakly than the type colon.
 Thus the expression is equal to the following.
\end_layout

\begin_layout LyX-Code
(
\backslash
$x:$T.$T).(add:OPTYPE)
\end_layout

\begin_layout Standard
The applicative dot can be used to 
\begin_inset Quotes eld
\end_inset

glue
\begin_inset Quotes erd
\end_inset

 any two atoms together.
 The atom to the left of the dot is the 
\emph on
left-hand side (lhs)
\emph default
, while the atom to the right of the dot is the 
\emph on
right-hand side (rhs)
\emph default
.
 For instance the following are perfectly legal applications, though it
 is not entirely clear what the first and last examples 
\begin_inset Quotes eld
\end_inset

mean.
\begin_inset Quotes erd
\end_inset

 The parentheses are used in the first example to prevent 
\family typewriter
7.

\family default
 from being interpreted as a floating point number; a space between the
 
\family typewriter
7
\family default
 and the dot would also work.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="4">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
(7).$x
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
(
\backslash
$x:$T.$T).add:OPTYPE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
add.%(5,6)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
$x.$y
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Just as an operator can stand by itself (
\family typewriter
add:OPTYPE
\family default
), so can an argument list.
 The odd notation 
\family typewriter
%(4,5,$x)
\family default
 specifies an atom list whose elements are, in order, 
\family typewriter
4
\family default
, 
\family typewriter
5
\family default
, and 
\family typewriter
$x
\family default
.
 Using tools discussed later, it is possible to take an atom like 
\family typewriter
add(4,5,$x)
\family default
 and divide it into the operator and the argument list.
 Because the argument list can become detached from the operator, we allow
 specifying the associativity and commutativity of the argument list independent
ly of the operator.
 The following are some examples of lists.
\end_layout

\begin_layout Itemize

\family typewriter
%(4,5,$x)
\family default
 is a list whose associativity, commutativity, and idempotency are unspecified.
\end_layout

\begin_layout Itemize

\family typewriter
%A(4,5,$x)
\family default
 is an associative list whose other properties are unspecified.
\end_layout

\begin_layout Itemize

\family typewriter
%C(4,5,$x)
\family default
 is a commutative list whose other properties are unspecified.
\end_layout

\begin_layout Itemize

\family typewriter
%I(4,5,$x)
\family default
 is an idempotent list whose other properties are unspecified.
\end_layout

\begin_layout Itemize

\family typewriter
%AC(4,5,$x)
\family default
 is a list that is both associative and commutative.
\end_layout

\begin_layout Itemize

\family typewriter
%A!I(4,5,$x)
\family default
 is a list that is associative but not idempotent.
 Commutativity is unspecified.
\end_layout

\begin_layout Itemize

\family typewriter
%!A!C(4,5,$x)
\family default
 is a list that is neither associative nor commutative, but whose idempotency
 is unspecified.
\end_layout

\begin_layout Standard
The first case is the one we have been using, as it allows the argument
 list to 
\begin_inset Quotes eld
\end_inset

inherit
\begin_inset Quotes erd
\end_inset

 all the properties of the operator or context in which it is applied.
 In short, if you care about a property, specify it, and use the exclamation
 point (
\family typewriter
!
\family default
) to negate a property.
 The order is 
\emph on
not
\emph default
 important: 
\family typewriter
%I!CA(4,5,$x)
\family default
 is perfectly fine, and case does not matter: 
\family typewriter
%i!Ca(4,5,$x)
\family default
 is also fine.
\end_layout

\begin_layout Standard
Making a list idempotent has an immediate effect: duplicates are removed.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> %I(4,5,4,5,4,5)
\end_layout

\begin_layout Plain Layout

$repl14 = %I(4,5)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Likewise, associative lists are flattened 
\emph on
provided
\emph default
 the subordinate lists have the same specified properties.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> %A(%A(4,3),6)
\end_layout

\begin_layout Plain Layout

$repl15 = %A(4, 3, 6)
\end_layout

\begin_layout Plain Layout

e> %A(%(4,3),6)
\end_layout

\begin_layout Plain Layout

$repl16 = %A(%(4, 3), 6)
\end_layout

\begin_layout Plain Layout

e> %A(%AC(4,3),6)
\end_layout

\begin_layout Plain Layout

$repl17 = %A(%AC(4, 3), 6)
\end_layout

\begin_layout Plain Layout

e> %AI(%AI(4,3,6),6)
\end_layout

\begin_layout Plain Layout

$repl18 = %AI(4,3,6)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Special-Forms"

\end_inset

 will introduce several other uses of the applicative dot.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Atom lists are instances of 
\family typewriter
core.AtomList
\family default
.
 To create an atom list, collect the atoms into an instance of any 
\family typewriter
scala.collection.IndexedSeq
\family default
, such as a 
\family typewriter
scala.collection.immutable.Vector
\family default
.
 Pass this sequence, along with the optional properties, to the 
\family typewriter
core.AtomList
\family default
 constructor.
 The properties are specified using the same method as for operators.
 Properties are given first in their own argument list, and the elements
 of the list are given in a second argument list.
\end_layout

\begin_layout Plain Layout
The lists 
\family typewriter
%(4,5,$x)
\family default
, 
\family typewriter
%!A(4,5,$x)
\family default
, and 
\family typewriter
%!CA(4,5,$x)
\family default
 can be constructed with the following code.
\end_layout

\begin_layout LyX-Code
AtomList()(4, 5, 'x)
\end_layout

\begin_layout LyX-Code
AtomList(!Associative)(4, 5, 'x)
\end_layout

\begin_layout LyX-Code
AtomList(!Commutative and Associative)(4, 5, 'x)
\end_layout

\begin_layout Plain Layout
To create an apply, use the 
\family typewriter
core.Apply(lhs,rhs)
\family default
 constructor, where 
\family typewriter
lhs
\family default
 is the left-hand side, and 
\family typewriter
rhs
\family default
 is the right-hand side.
 Here are the Scala code equivalents for the apply examples given previously.
\end_layout

\begin_layout LyX-Code
// (7).$x
\end_layout

\begin_layout LyX-Code
Apply(7,'x)
\end_layout

\begin_layout LyX-Code

\family typewriter
// (
\backslash
$x:$T.$T).add:OPTYPE
\end_layout

\begin_layout LyX-Code
Apply(Lambda(Variable('T,"x"),'T), Literal(OPTYPE,'add))
\end_layout

\begin_layout LyX-Code
// add.%(5,6)
\end_layout

\begin_layout LyX-Code
Apply(context.operatorLibrary("add"), AtomList()(5,6))
\end_layout

\begin_layout LyX-Code
// $x.$y
\end_layout

\begin_layout LyX-Code
Apply('x,'y)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Operators, Symbols, and Naked Symbols
\end_layout

\begin_layout Standard
If you type a symbol at the REPL prompt without type, this is regarded as
 a 
\begin_inset Quotes eld
\end_inset

naked
\begin_inset Quotes erd
\end_inset

 symbol, and is subject to special treatment.
 If the naked symbol appears on the left-hand side of an apply, the system
 will attempt to interpret it as an operator, and will look it up in the
 context.
 If it is not found, it will issue an error.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> fred
\end_layout

\begin_layout Plain Layout

$repl14 = fred:SYMBOL
\end_layout

\begin_layout Plain Layout

e> fred(5)
\end_layout

\begin_layout Plain Layout

ERROR: The operator fred is not known.
\end_layout

\begin_layout Plain Layout

e> fred.james
\end_layout

\begin_layout Plain Layout

ERROR: The operator fred is not known.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To overcome this explicitly give the type of the symbol.
 Any type will suppress this behavior, but the most common (and obvious)
 type is 
\family typewriter
SYMBOL
\family default
.
 Enclosing the symbol in parentheses only helps with the simple operator
 application, and not the applicative dot.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> fred:SYMBOL.james
\end_layout

\begin_layout Plain Layout

$repl15 = fred:SYMBOL.james
\end_layout

\begin_layout Plain Layout

e> (fred)(5)
\end_layout

\begin_layout Plain Layout

$repl16 = fred:SYMBOL
\end_layout

\begin_layout Plain Layout

$repl17 = 5
\end_layout

\begin_layout Plain Layout

e> (fred).5
\end_layout

\begin_layout Plain Layout

ERROR: The operator fred is not known.
\end_layout

\begin_layout Plain Layout

e> (fred:SYMBOL).5
\end_layout

\begin_layout Plain Layout

$repl18 = (fred:SYMBOL.5)
\end_layout

\begin_layout Plain Layout

e> fred:SYMBOL(5)
\end_layout

\begin_layout Plain Layout

ERROR: The operator SYMBOL is not known.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The last line above is included just to emphasize that types are themselves
 atoms, and are subject to the same parsing rules.
\end_layout

\begin_layout Standard
The opposite of this is to explicitly state that a symbol denotes an operator,
 using 
\family typewriter
OPTYPE
\family default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> (fred:OPTYPE)(5)
\end_layout

\begin_layout Plain Layout

ERROR: The operator fred is not known.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You may be wondering why Elision doesn't simply treat a naked symbol as
 a simple symbol when there is no operator with that name, so 
\family typewriter
fred.5
\family default
 would be accepted.
 The reason is that if an operator with name 
\family typewriter
fred
\family default
 were later defined then the interpretation would be fundamentally changed
 (from a symbol to an operator), and the Elision design seeks to avoid that.
 This could 
\begin_inset Quotes eld
\end_inset

break
\begin_inset Quotes erd
\end_inset

 existing files of definitions and terms.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
The special type 
\family typewriter
OPTYPE
\family default
 is one place where the Scala API and REPL deviate.
 Consider the following code.
\end_layout

\begin_layout LyX-Code
Apply(Literal(OPTYPE, 'fred), Literal(5)).toParseString
\end_layout

\begin_layout Plain Layout
This yields the output 
\begin_inset Quotes eld
\end_inset


\family typewriter
(fred:OPTYPE.5)
\family default
,
\begin_inset Quotes erd
\end_inset

 but this fails the 
\begin_inset Quotes eld
\end_inset

round trip
\begin_inset Quotes erd
\end_inset

 test.
 Parsing this string results in an attempt to look up the 
\family typewriter
fred
\family default
 operator in the current context.
\end_layout

\begin_layout Plain Layout
This difficulty arises from the fact that there is no 
\begin_inset Quotes eld
\end_inset

universal
\begin_inset Quotes erd
\end_inset

 context.
 The REPL and the parser have a context where they can look up 
\family typewriter
fred
\family default
, but the overall API does not.
\end_layout

\begin_layout Plain Layout
To prevent this future versions of Elision may do away with 
\family typewriter
OPTYPE
\family default
 at the API level, and more rigorously dispose of it during parsing, but
 for now remember that this is a piece of parser 
\begin_inset Quotes eld
\end_inset

magic.
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Case Definitions
\end_layout

\begin_layout Standard
A case definition defines an operator by explicitly giving the interpretation
 of the operator in terms of its argument.
 When the operator symbol appears on the left of an applicative dot (even
 when implicit) then the argument is matched against a sequence of alternatives,
 in order.
 If one matches, then the rewrite is applied, yielding the final atom.
 If none apply, then the application is rejected, as it does not satisfy
 the operator definition.
\end_layout

\begin_layout Standard
The following is a general definition of 
\family typewriter
add
\family default
 using cases.
\end_layout

\begin_layout LyX-Code
{operator add case
\end_layout

\begin_layout LyX-Code
          %($x: INTEGER) -> $x,
\end_layout

\begin_layout LyX-Code
          %($x: STRING) -> $x,
\end_layout

\begin_layout LyX-Code
          %AC($x: INTEGER, $y: INTEGER) -> iadd($x,$y),
\end_layout

\begin_layout LyX-Code
          %A($x: STRING, $y: STRING) -> concat($x,$y)}
\end_layout

\begin_layout Standard
This definition allows adding both integers (via 
\family typewriter
iadd
\family default
) and strings (via 
\family typewriter
concat
\family default
).
 Note that the lists can specify properties to facilitate proper matching.
 Note also that 
\family typewriter
add(5,"Fred")
\family default
 results in an error, as this is an undefined case.
\end_layout

\begin_layout Standard
Suppose we never want an undefined case; when we do not match a given case,
 we want to accept and leave the operator application unchanged, perhaps
 for symbolic manipulation.
 Consider the following alternate definition of 
\family typewriter
add
\family default
.
\end_layout

\begin_layout LyX-Code
{operator add case
\end_layout

\begin_layout LyX-Code
          %($x: INTEGER) -> $x,
\end_layout

\begin_layout LyX-Code
          %($x: STRING) -> $x,
\end_layout

\begin_layout LyX-Code
          %AC($x: INTEGER, $y: INTEGER) -> iadd($x,$y),
\end_layout

\begin_layout LyX-Code
          %A($x: STRING, $y: STRING) -> concat($x,$y),
\end_layout

\begin_layout LyX-Code
          $x:_ -> $_.$x}
\end_layout

\begin_layout Standard
That last line requires explanation.
 The pattern matches anything and binds it to 
\family typewriter
$x
\family default
.
 The rewrite uses the special variable 
\family typewriter
$_
\family default
 that is explicitly defined in the context of the operator definition to
 designate the 
\family typewriter
add
\family default
 operator we are constructing.
 Thus 
\family typewriter
add(5,"Fred")
\family default
 falls to this case, with 
\family typewriter
$x
\family default
 bound to 
\family typewriter
%(5,"Fred")
\family default
, and the rewrite becoming 
\family typewriter
add:OPTYPE.%(5,"Fred")
\family default
, or just 
\family typewriter
add(5,"Fred")
\family default
, where construction halts.
 We cannot refer to 
\family typewriter
add
\family default
 in this context since the operator is not yet defined.
\end_layout

\begin_layout Standard
The examples given so far all use 
\begin_inset Quotes eld
\end_inset

map pairs,
\begin_inset Quotes erd
\end_inset

 or atoms of the form 
\emph on
pattern
\emph default
 
\family typewriter
->
\family default
 
\emph on
rewrite
\emph default
.
 In fact, any strategy can be used.
 The first strategy to report success yields the answer.
 Also, after the strategy has completed, the binding 
\family typewriter
$_ -> add:OPTYPE
\family default
 is applied to enable referring to the operator in the rewrites.
\end_layout

\begin_layout Standard
This generality allows some rather unorthodox things to occur.
 Consider the following.
\end_layout

\begin_layout LyX-Code
{operator typeof case $x:$T -> $T}
\end_layout

\begin_layout Standard
Now we have an operator that generates the type of anything on the right
 of an applicative dot.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> typeof.5
\end_layout

\begin_layout Plain Layout

$repl4 = INTEGER
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is possible to do even stranger things.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> {operator swap case $x -> $x.$_}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Special-Forms"

\end_inset

Special Forms
\end_layout

\begin_layout Standard
Elision 
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Matching-and-Rewriting"

\end_inset

Matching and Rewriting
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Rules-and-Strategies"

\end_inset

Rules and Strategies
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Contexts"

\end_inset

Contexts
\end_layout

\begin_layout Chapter
\start_of_appendix
BasicAtom
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:De-Bruijn-Indices"

\end_inset

De Bruijn Indices
\end_layout

\begin_layout Standard
Elision converts lambdas into a representation using a form of De Bruijn
 indices.
 This appendix describes how they are implemented in Elision.
\end_layout

\begin_layout Standard
A 
\begin_inset Quotes eld
\end_inset

proper
\begin_inset Quotes erd
\end_inset

 De Bruijn index indicates the the number of binds that are in scope.
 Thus the lambda 
\begin_inset Formula $\lambda x.\lambda y.x$
\end_inset

 should correctly produce the De Bruijn term 
\begin_inset Formula $\lambda\lambda2$
\end_inset

, as the body binds to the outermost lambda.
 Elision does not actually use proper De Bruijn indices, but uses a very
 similar concept somewhere in between symbolic names and De Bruijn indices.
\end_layout

\begin_layout Standard
In Elision every atom has an associated De Bruijn index.
 Literals and (most) variables have index zero.
 Other terms have De Bruijn index equal to the maximum index of their parts.
\end_layout

\begin_layout Standard
Suppose we are given a lambda term such as 
\family typewriter

\backslash
$x.add($x,$y)
\family default
.
 The body contains no lambdas or De Bruijn indices, so it has De Bruijn
 index zero.
 The lambda parameter also contains no lambdas or De Bruijn indices, so
 it also has De Bruijn index zero.
 Thus the maximum De Bruijn index of the parts is zero.
 Since we are constructing a lambda, we increment the maximum index, obtaining
 one.
 The system constructs a special variable 
\family typewriter
$`:1`
\family default
 representing the De Bruijn index, and then rewrites lambda parameter and
 body with 
\family typewriter
$x -> $`:1`
\family default
, obtaining the result 
\family typewriter

\backslash
$`:1`.add($`:1`, $y)
\family default
.
\end_layout

\begin_layout Standard
Next consider 
\family typewriter

\backslash
$x.
\backslash
$y.$x
\family default
.
 First 
\family typewriter

\backslash
$y.$x
\family default
 is constructed, yielding 
\family typewriter

\backslash
$`:1`.$x
\family default
, whose Dr Bruijn index (assigned by Elision) is one.
 Next we construct 
\family typewriter

\backslash
$x.(
\backslash
$`:1`.$x)
\family default
.
 The De Bruijn index of the parameter is zero, and of the body is one, so
 the De Bruijn index to use for the new expression is 
\family typewriter
$`:2`
\family default
, and we rewrite with 
\family typewriter
$x -> $`:2`
\family default
.
 The trick is that the rewrite actually causes us to re-build the lambdas.
 Rewriting the body 
\family typewriter

\backslash
$`:1`.$x
\family default
 results in a new lambda whose body is 
\family typewriter

\backslash
$`:2`
\family default
 with De Bruijn index of two, and thus the entire lambda constructs a new
 
\end_layout

\begin_layout Chapter
Grammar
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
term}[1]{
\backslash
fbox{
\backslash
texttt{#1}}}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
citerm}[1]{
\backslash
doublebox{
\backslash
texttt{#1}}}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand
\backslash
defntx[1]{~
\backslash

\backslash
[1em]
\backslash
textbf{#1}~::=~}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand
\backslash
defnt[1]{~
\backslash

\backslash
[1em]
\backslash
textbf{#1}~::=~}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
nt}[1]{
\backslash
emph{#1}}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
ordef}{~
\backslash

\backslash

\backslash
hspace{0.5in}|~}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
shortor}{~|~}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
zeroOrMore}[1]{(#1){*}}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
optional}[1]{(#1)?}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
caret}{
\backslash
textasciicircum{}}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
juxt}{$
\backslash
cdot$}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The grammar for Elision is described in extended Backus-Naur form (EBNF)
 in this appendix.
 Terminals are indicated with text in fixed font, boxed, as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
term{terminal}
\end_layout

\end_inset

.
 Elision is normally case-sensitive, but some terminals are case-insensitive.
 These are indicated with a double box, as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
citerm{terminal}
\end_layout

\end_inset

.
 Nonterminals are indicated with italics, as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nt{nonterminal}
\end_layout

\end_inset

.
 Character ranges in unicode are indicated by a dash, so any single nonzero
 digit is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
term{1}
\end_layout

\end_inset

-
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
term{9}
\end_layout

\end_inset

.
 Productions are indicated with ::=.
 Parentheses indicate grouping.
 If an item may appear zero or more times, this is indicated with a suffixed
 asterisk, as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
zeroOrMore{
\backslash
nt{atom}}
\end_layout

\end_inset

.
 Optional items are indicated with a suffixed question mark, as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
optional{
\backslash
nt{atom}}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In general arbitrary white space is allowed.
 When no whitespace is allowed between two elements of the grammar, the
 elements are joined by a dot, as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
term{
\backslash
#}
\backslash
juxt
\backslash
nt{atom}
\end_layout

\end_inset

.
 The special terminal 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
term{ANY}
\end_layout

\end_inset

 is described at the end, and corresponds to any character other than the
 backslash 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
term{
\backslash
textbackslash}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
defnt{atom-seq} 
\backslash
zeroOrMore{
\backslash
nt{atom}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{atom} 
\backslash
nt{first-atom} 
\backslash
term{->} 
\backslash
nt{first-atom}
\end_layout

\begin_layout Plain Layout


\backslash
ordef
\backslash
nt{first-atom} 
\backslash
zeroOrMore{
\backslash
term{.} 
\backslash
nt{first-atom})}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{first-atom} 
\backslash
term{(} 
\backslash
nt{atom} 
\backslash
term{)}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{special-form}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{lambda}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{apply}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{typed-list}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{alg-prop}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{variable}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{operator-symbol}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{literal}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{number}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
term{
\backslash
caret TYPE}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{special-form} 
\backslash
term{
\backslash
{:} 
\backslash
nt{atom} 
\backslash
nt{atom} 
\backslash
term{:
\backslash
}}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
term{
\backslash
{} 
\backslash
nt{atom} 
\backslash
zeroOrMore{
\backslash
nt{atom}}
\end_layout

\begin_layout Plain Layout

		
\backslash
zeroOrMore{
\backslash
nt{sf-bound-atom}|
\backslash
nt{sf-bound-list}} 
\backslash
term{
\backslash
}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{sf-bound-atom} 
\backslash
term{
\backslash
#}
\backslash
juxt
\backslash
nt{SYMBOL} 
\backslash
term{=} 
\backslash
nt{atom}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{sf-bound-list} 
\backslash
term{
\backslash
#}
\backslash
juxt
\backslash
nt{SYMBOL} 
\backslash
zeroOrMore{
\backslash
nt{atom}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{lambda} 
\backslash
term{
\backslash
textbackslash{}} 
\backslash
nt{variable} 
\backslash
term{.} 
\backslash
nt{first-atom}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{apply} 
\backslash
nt{SYMBOL} 
\backslash
term{(} 
\backslash
nt{atom-sequence} 
\backslash
term{)}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{atom-sequence} 
\backslash
nt{atom} 
\backslash
zeroOrMore{
\backslash
term{,} 
\backslash
nt{atom}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{typed-list} 
\backslash
nt{alg-prop} 
\backslash
term{(} 
\backslash
nt{atom-sequence} 
\backslash
term{)}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{alg-prop} 
\backslash
term{
\backslash
%}
\backslash
juxt 
\backslash
zeroOrMore{
\end_layout

\begin_layout Plain Layout

	
\backslash
citerm{A}
\backslash
optional{
\backslash
term{=}
\backslash
nt{atom}}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
citerm{C}
\backslash
optional{
\backslash
term{=}
\backslash
nt{atom}}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
citerm{I}
\backslash
optional{
\backslash
term{=}
\backslash
nt{atom}}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
citerm{!A}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
citerm{!C}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
citerm{!I}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
citerm{B}
\backslash
term{[}
\backslash
nt{atom}
\backslash
term{]}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
citerm{D}
\backslash
term{[}
\backslash
nt{atom}
\backslash
term{]}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{variable} (
\backslash
term{
\backslash
$}
\backslash
shortor
\backslash
term{
\backslash
$
\backslash
$})
\end_layout

\begin_layout Plain Layout

	
\backslash
nt{SYMBOL}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
term{
\backslash
{} 
\backslash
nt{atom} 
\backslash
term{
\backslash
}}}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
term{:} 
\backslash
nt{first-atom}}
\end_layout

\begin_layout Plain Layout

	
\backslash
zeroOrMore{
\backslash
term{@} 
\backslash
nt{SYMBOL}}
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout


\backslash
defnt{operator-symbol} 
\backslash
nt{SYMBOL} 
\backslash
term{:} 
\backslash
term{OPTYPE}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{literal} 
\backslash
nt{SYMBOL}
\backslash
shortor
\backslash
nt{STRING}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{number} 
\backslash
nt{any-number} 
\backslash
optional{
\backslash
term{:} 
\backslash
nt{first-atom}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{any-number} 
\backslash
nt{hex-number}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor 
\backslash
nt{hex-number}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor 
\backslash
nt{binary-number}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor 
\backslash
nt{decimal-number}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor 
\backslash
nt{octal-number}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{hex-number} 
\backslash
nt{hex-integer}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
juxt
\backslash
term{.}
\backslash
nt{hex-digit}}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
juxt
\backslash
citerm{P}
\backslash
juxt
\backslash
nt{exponent}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{binary-number}
\backslash
nt{binary-integer}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
juxt
\backslash
term{.}
\backslash
juxt
\backslash
nt{binary-digit}}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
juxt(
\backslash
citerm{E}
\backslash
shortor
\backslash
citerm{P})
\backslash
juxt
\backslash
nt{exponent}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{decimal-number}
\backslash
nt{decimal-integer}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
juxt
\backslash
term{.}
\backslash
juxt
\backslash
nt{decimal-digit}}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
juxt(
\backslash
citerm{E}
\backslash
shortor
\backslash
citerm{P})
\backslash
juxt
\backslash
nt{exponent}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{octal-number}
\backslash
nt{octal-integer}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
juxt
\backslash
term{.}
\backslash
juxt
\backslash
nt{octal-digit}}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
juxt(
\backslash
citerm{E}
\backslash
shortor
\backslash
citerm{P})
\backslash
juxt
\backslash
nt{exponent}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{exponent} 
\backslash
optional{
\backslash
term{-}
\backslash
shortor
\backslash
term{+}} 
\backslash
juxt
\backslash
nt{any-integer}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{any-integer} 
\backslash
nt{hex-integer}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor 
\backslash
nt{hex-integer}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor 
\backslash
nt{binary-integer}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor 
\backslash
nt{decimal-integer}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor 
\backslash
nt{octal-integer}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{hex-integer} 
\backslash
citerm{0X} 
\backslash
juxt
\backslash
zeroOrMore{
\backslash
nt{hex-digit}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{binary-integer} 
\backslash
citerm{0B} 
\backslash
juxt
\backslash
zeroOrMore{
\backslash
term{0}
\backslash
shortor
\backslash
term{1}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{decimal-integer} 
\backslash
term{1}-
\backslash
term{9} 
\backslash
juxt
\backslash
zeroOrMore{
\backslash
nt{digit}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{octal-integer} 
\backslash
term{0} 
\backslash
juxt
\backslash
zeroOrMore{
\backslash
term{0}-
\backslash
term{7}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{hex-digit} 
\backslash
citerm{A}-
\backslash
citerm{F}
\backslash
shortor
\backslash
nt{digit}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{SYMBOL} (
\backslash
nt{letter}
\backslash
shortor
\backslash
term{
\backslash
_}) 
\backslash
juxt
\backslash
zeroOrMore{
\backslash
nt{letter}
\backslash
shortor
\backslash
nt{digit}
\backslash
shortor
\backslash
term{
\backslash
_}}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
term{`} 
\backslash
juxt
\backslash
zeroOrMore{
\backslash
nt{escape}
\backslash
shortor
\backslash
nt{ANY}} 
\backslash
juxt
\backslash
term{`}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{STRING} 
\backslash
term{"} 
\backslash
juxt
\backslash
zeroOrMore{
\backslash
nt{escape}
\backslash
shortor 
\backslash
nt{ANY}} 
\backslash
juxt
\backslash
term{"}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{escape} 
\backslash
term{
\backslash
textbackslash{}"}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor
\backslash
term{
\backslash
textbackslash{}"}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor
\backslash
term{
\backslash
textbackslash{}'}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor
\backslash
term{
\backslash
textbackslash{}n}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor
\backslash
term{
\backslash
textbackslash{}r}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor
\backslash
term{
\backslash
textbackslash{}t}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor
\backslash
term{
\backslash
textbackslash{}
\backslash
textbackslash{}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{letter} 
\backslash
citerm{A}-
\backslash
citerm{Z}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{digit} 
\backslash
term{0}-
\backslash
term{9}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{ANY} 
\backslash
emph{Any character other than} 
\backslash
term{
\backslash
textbackslash{}}.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_body
\end_document
