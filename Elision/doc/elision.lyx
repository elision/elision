#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass amsbook
\begin_preamble
%%\usepackage{minted}
\usepackage{tipa}
\definecolor{shadecolor}{rgb}{0.8,0.8,1}
\sloppypar
%\usepackage{nameref}
\usepackage{fancybox}
\newenvironment{elision}{%
\VerbatimEnvironment
\begin{lstlisting}%
}{%
\end{lstlisting}%
}
\definecolor{listing}{RGB}{224,224,224}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\boxbgcolor #3ebcbc
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "backgroundcolor={\color{listing}},basewidth={.5em},basicstyle={\ttfamily\small},columns=fixed,commentstyle={\color{blue}\emph},language=Java,morecomment={[l]{e>}},morecomment={[l]{q>}},morecomment={[l]{\ >}},numbers=none"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Elision User Guide
\end_layout

\begin_layout Dedicatory
Version @VERSION@ Build @BUILD@
\end_layout

\begin_layout Standard

\series bold
\shape italic
\size larger
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
makebox[0pt][r]{nominatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Linguistically, an 
\emph on
elision
\emph default
 (
\begin_inset ERT
status open

\begin_layout Plain Layout

i'liZH
\backslash
textipa{@}n
\end_layout

\end_inset

) is the omission of sounds from an utterance to create a result that is
 (typically) easier to pronounce.
 Contractions are examples of elisions.
 Elision can also refer to omissions in books and films.
 Finally, it may mean the process of joining or merging together abstract
 ideas.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
Elision is distributed under the following modified BSD 
\begin_inset Quotes eld
\end_inset

two clause
\begin_inset Quotes erd
\end_inset

 license.
\end_layout

\begin_layout LyX-Code
      _ _     _
\end_layout

\begin_layout LyX-Code
  ___| (_)___(_) ___  _ __
\end_layout

\begin_layout LyX-Code
 / _ 
\backslash
 | / __| |/ _ 
\backslash
| '_ 
\backslash

\end_layout

\begin_layout LyX-Code
|  __/ | 
\backslash
__ 
\backslash
 | (_) | | | |
\end_layout

\begin_layout LyX-Code
 
\backslash
___|_|_|___/_|
\backslash
___/|_| |_|
\end_layout

\begin_layout LyX-Code
The Elision Term Rewriter
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
Copyright (c) 2012 by UT-Battelle, LLC.
\end_layout

\begin_layout LyX-Code
All rights reserved.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
Redistribution and use in source and binary forms, with or without
\end_layout

\begin_layout LyX-Code
modification, are permitted provided that the following conditions are met:
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
1.
 Redistributions of source code must retain the above copyright notice,
 this
\end_layout

\begin_layout LyX-Code
   list of conditions and the following disclaimer.
\end_layout

\begin_layout LyX-Code
2.
 Redistributions in binary form must reproduce the above copyright notice,
\end_layout

\begin_layout LyX-Code
   this list of conditions and the following disclaimer in the documentation
\end_layout

\begin_layout LyX-Code
   and/or other materials provided with the distribution.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
Collection of administrative costs for redistribution of the source code
 or
\end_layout

\begin_layout LyX-Code
binary form is allowed.
 However, collection of a royalty or other fee in excess
\end_layout

\begin_layout LyX-Code
of good faith amount for cost recovery for such redistribution is prohibited.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 IS"
\end_layout

\begin_layout LyX-Code
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
\end_layout

\begin_layout LyX-Code
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
\end_layout

\begin_layout LyX-Code
ARE DISCLAIMED.
 IN NO EVENT SHALL THE COPYRIGHT HOLDER, THE DOE, OR
\end_layout

\begin_layout LyX-Code
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
\end_layout

\begin_layout LyX-Code
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
\end_layout

\begin_layout LyX-Code
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
\end_layout

\begin_layout LyX-Code
OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
\end_layout

\begin_layout LyX-Code
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
\end_layout

\begin_layout LyX-Code
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
\end_layout

\begin_layout LyX-Code
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\end_layout

\begin_layout Chapter
Installation
\end_layout

\begin_layout Standard
This chapter explains how to build the Elision rewriter.
 Information about the rewriter can be obtained by visiting 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://stacyprowell.com/wiki/doku.php?id=elision
\end_layout

\end_inset

.
 This page contains a frequently updated version, along with documentation
 links and a link to Elision's github page at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/sprowell/elision
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Elision contains Parboiled, a parser expression grammar (PEG) library.
 See 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/sirthias/parboiled/wiki
\end_layout

\end_inset

 for details, including the license agreement.
 The Elision REPL uses JLine, a Java library for handling console input.
 See 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/jline/jline2
\end_layout

\end_inset

 for details, including the license agreement.
 Note that Elision actually uses the modified version of JLine built for
 the Scala REPL and distributed with Scala.
\end_layout

\begin_layout Section
Prerequisites
\end_layout

\begin_layout Standard
Elision requires Scala 2.9 or later to build.
 Be careful with later versions of Scala as the language is still changing
 quite a bit.
 Java 6 or later and Apache Ant 1.8 or later are also prerequisites.
\end_layout

\begin_layout Enumerate
Install the Java 6 (or later) SDK.
 Visit 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://java.oracle.com
\end_layout

\end_inset

 to download the correct version for your platform.
\end_layout

\begin_layout Enumerate
Install Scala 2.9.1 (or later).
 Visit 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.scala-lang.org
\end_layout

\end_inset

 to download the Scala distribution.
\end_layout

\begin_layout Enumerate
Set the environment variable 
\family typewriter
SCALA_HOME
\family default
 to point to the root folder of your Scala installation (the folder that
 contains the 
\family typewriter
bin
\family default
 and 
\family typewriter
lib
\family default
 folders).
\end_layout

\begin_deeper
\begin_layout Enumerate
On Windows platforms you should edit the environment variable settings under
 System, and add 
\family typewriter
%SCALA_HOME%
\backslash
bin
\family default
 to the 
\family typewriter
Path
\family default
 environment variable.
 Open 
\family sans
System Properties
\family default
 and click 
\family sans
Advanced system settings
\family default
.
 Then on the 
\family sans
Advanced
\family default
 tab click 
\family sans
Environment Variables...

\family default
 Under 
\family sans
System Variables
\family default
 click 
\family sans
New...
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Variable name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Variable value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
SCALA_HOME
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
C:
\backslash
scala
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
You should replace 
\family typewriter
C:
\backslash
scala
\family default
 with the directory where you installed Scala.
 Next edit the value for 
\family typewriter
Path
\family default
 
\emph on
carefully
\emph default
 to add 
\family typewriter
;%SCALA_HOME%
\backslash
bin
\family default
 on the end.
\end_layout

\end_deeper
\begin_layout Enumerate
On MacOS X platforms you can edit the environment plist 
\emph on
or
\emph default
 follow the directions for UNIX below.
 You can do this from the Terminal prompt with 
\family typewriter
open ~/.MacOSX/environment.plist
\family default
.
 This will open the environment settings in the 
\family sans
Property List Editor
\family default
.
 Add a new 
\family sans
Item
\family default
 at the top level.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Key
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
Value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
SCALA_HOME
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
/usr/local/scala
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
You should replace 
\family typewriter
/usr/local/scala
\family default
 with the directory where you installed Scala.
 Next edit the value for 
\family typewriter
PATH
\family default
 
\emph on
carefully
\emph default
 to add 
\family typewriter
:$SCALA_HOME/bin
\family default
 on the end.
\end_layout

\end_deeper
\begin_layout Enumerate
On modern UNIX systems (including MacOS X) and most Linux systems you can
 create a 
\family typewriter
/etc/profile.d/scala.sh
\family default
 file with the following content:
\end_layout

\begin_deeper
\begin_layout LyX-Code
# Add Scala
\begin_inset Newline newline
\end_inset

export SCALA_HOME=/usr/local/scala
\begin_inset Newline newline
\end_inset

PATH=${PATH}:$SCALA_HOME/bin
\end_layout

\begin_layout Standard
You should replace 
\family typewriter
/usr/local/scala
\family default
 with the directory where you installed Scala.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
(Optional) It is recommended to get the Scala developer documentation package.
 After you have installed Scala, run the following command at the prompt.
 If you have installed Scala in a folder owned by root on Linux or UNIX,
 you will need to precede the command with 
\family typewriter
sudo
\family default
.
\begin_inset Newline newline
\end_inset


\family typewriter
sbaz install scala-devel-docs
\end_layout

\begin_layout Enumerate
Install Apache Ant 1.8 (or later).
 Visit 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://ant.apache.org
\end_layout

\end_inset

 to download the Ant distribution.
\end_layout

\begin_layout Enumerate
If you want to use Eclipse, you should install Eclipse Indigo (or later).
\end_layout

\begin_layout Section
Building
\end_layout

\begin_layout Standard
To build the Elision jar file, 
\family typewriter
cd
\family default
 to the root folder of the Elision distribution and run the command 
\family typewriter
ant
\family default
.
 This will build the jar file.
 If you want to build the API documentation, then run the command 
\family typewriter
ant docs
\family default
.
 To do both, use 
\family typewriter
ant all
\family default
.
 To see what other targets are available, use 
\family typewriter
ant -p
\family default
.
\end_layout

\begin_layout Section
REPL
\end_layout

\begin_layout Standard
Elision comes with a read, evaluate, print loop interpreter (a REPL).
 You can start it in any of the following ways.
\end_layout

\begin_layout Itemize
Use the 
\family typewriter
repl.sh
\family default
 script found in the root folder of the Elision distribution.
 This starts the REPL using the compiled class files in the 
\family typewriter
bin
\family default
 folder, and is the best way to run it if you are using a continuous build
 system such as Eclipse.
 If you try to run the REPL this way while Eclipse is compiling, you will
 get missing class file errors.
 Just wait for Eclipse to finish compiling.
\end_layout

\begin_layout Itemize
To run the REPL from the jar file, execute the command 
\family typewriter
scala elision.jar
\family default
.
 If the Scala library is available in 
\family typewriter
scala-library.jar
\family default
 then you can also run it with 
\family typewriter
java -cp scala-library.jar -jar elision.jar
\family default
.
 You must have built the jar file to use this method, and must update it
 each time you make changes.
\end_layout

\begin_layout Itemize
To start the REPL from inside a program, invoke the 
\family typewriter
ornl.elision.repl.Repl.run()
\family default
 method.
\end_layout

\begin_layout Standard
To exit from the REPL use 
\family typewriter
:quit
\family default
.
 To get help use 
\family typewriter
help()
\family default
.
 The REPL is the subject of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Interacting-with-the"

\end_inset

.
\end_layout

\begin_layout Section
Emacs, Notepad-Plus, and Others
\end_layout

\begin_layout Standard
Most editors now come with a Scala mode installed.
 In case yours does not, you should look in the Scala distribution under
 
\family typewriter
misc/scala-tool-support
\family default
.
 We will provide some instructions for Emacs here.
\end_layout

\begin_layout Standard
The Emacs mode works for Emacs 21.1or later, and does not work on XEmacs.
 Things change; consult the 
\family typewriter
README
\family default
 file in the folder for current details.
 It is suggested you leave these files in place so they get magically updated
 when the next version of Scala is installed.
\end_layout

\begin_layout Standard
In your Emacs startup file (typically 
\family typewriter
~/.emacs
\family default
 on Linux or UNIX) add the following two lines.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Lisp"
inline false
status open

\begin_layout Plain Layout

(add-to-list 'load-path
\end_layout

\begin_layout Plain Layout

  "/usr/local/scala/misc/scala-tool-support/emacs")
\end_layout

\begin_layout Plain Layout

(require 'scala-mode-auto)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Adjust the second line as necessary to point to your Scala installation.
 Now restart Emacs, and you should get the Scala mode when you open a file
 ending with 
\family typewriter
.scala
\family default
.
 You can compile the 
\family typewriter
.el
\family default
 files to 
\family typewriter
.elc
\family default
 files using the provided 
\family typewriter
Makefile
\family default
, but be sure to run 
\family typewriter
make
\family default
 each time you update.
\end_layout

\begin_layout Section
Eclipse
\end_layout

\begin_layout Standard
The root folder of the Elision distribution contains an Eclipse project.
 Before you attempt to import it into Eclipse you should do the following.
\end_layout

\begin_layout Itemize
Install the 
\series bold
Scala IDE
\series default
.
 At present the version of the Scala IDE for Scala 2.9 can be found at the
 update site 
\begin_inset CommandInset href
LatexCommand href
target "http://download.scala-ide.org/releases-29/stable/site"

\end_inset

.
 Visit 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://scala-ide.org
\end_layout

\end_inset

 for the latest version, documentation, etc.
\end_layout

\begin_layout Standard
That is all that is required.
 You may optionally install the following helpful plugins.
\end_layout

\begin_layout Itemize

\series bold
ShellEd
\series default
 is an excellent editor for working with shell scripts, but at present it
 only works with Eclipse Indigo.
 You can find out more at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://sourceforge.net/apps/trac/shelled
\end_layout

\end_inset

.
 To install ShellEd you need to install components from the Linux Tools.
 The update site is 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://download.eclipse.org/technology/linuxtools/update
\end_layout

\end_inset

.
 Add this update site first, but do not install anything.
 The update site for ShellEd is 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://downloads.sourceforge.net/project/shelled/shelled/ShellEd%202.0.1/update
\end_layout

\end_inset

.
 After adding the update site for the Linux Tools, add this update site
 and then install ShellEd; it will resolve the dependencies and get the
 components from the Linux Tools that are actually required.
\end_layout

\begin_layout Itemize

\series bold
Copyright Wizard
\series default
 can be used to automatically and quickly update the copyrights on all files
 and to make sure all new files have the correct copyright information.
 The distribution includes a configuration file for Copyright Wizard that
 will be automatically discovered if you install Copyright Wizard.
 Find out more at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.wdev91.com/?p=cpw
\end_layout

\end_inset

.
 The update site is 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.wdev91.com/update
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Once you have installed the Scala IDE plugin, do the following.
\end_layout

\begin_layout Enumerate
Unpack the Elision distribution into an Eclipse workspace, or create a 
\family typewriter
workspace
\family default
 folder and place the 
\family typewriter
Elision
\family default
 folder in it.
\end_layout

\begin_layout Enumerate
Start Eclipse.
 You will probably be prompted to run the Scala Setup Diagnostics.
 Click Yes to run them.
 Make sure you open Eclipse in the correct workspace containing the Elision
 distribution.
\end_layout

\begin_layout Enumerate
Go to the workbench.
 Right-click in the package explorer and choose New and then Project.
 In the New Project wizard expand Scala Wizards and select Scala Project.
 Click Next.
\end_layout

\begin_layout Enumerate
In the New Scala Project dialog enter Elision as the project name.
 If you have done everything correctly you should see a note at the bottom
 of the dialog telling you the wizard is about to automatically configure
 the project based on the existing source.
 This is what you want, so click Finish.
\end_layout

\begin_layout Enumerate
You may be asked if you want to switch to the Scala perspective.
 You do, so click Yes.
\end_layout

\begin_layout Standard
At this point Elision should automatically build, and you are ready to start
 working with the code or running the REPL using 
\family typewriter
repl.sh
\family default
.
\end_layout

\begin_layout Section
Scala Code
\end_layout

\begin_layout Standard
Elision is written in Scala, and provides a Scala API.
 Discussions of the Scala API are highlighted in blue.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Elision's classes live in packages under 
\family typewriter
ornl.elision
\family default
.
 Throughout this document packages, classes, objects, traits, etc., will
 be discussed in reference to this top-level package.
 Thus 
\family typewriter
core.BasicAtom
\family default
 refers to the fully-qualified class name (FQCN) 
\family typewriter
ornl.elision.core.BasicAtom
\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Interacting-with-the"

\end_inset

Interacting with the REPL
\end_layout

\begin_layout Standard
The REPL is Elision's read, evaluate, print loop.
 It provides a way to interact directly with the rewriter.
\end_layout

\begin_layout Section
Starting the REPL
\end_layout

\begin_layout Standard
You can start the REPL in any of the following ways.
\end_layout

\begin_layout Itemize
Use the 
\family typewriter
repl.sh
\family default
 script found in the root folder of the Elision distribution.
 This starts the REPL using the compiled class files in the 
\family typewriter
bin
\family default
 folder, and is the best way to run it if you are using a continuous build
 system such as Eclipse.
\end_layout

\begin_layout Itemize
To run the REPL from the jar file, execute the command 
\family typewriter
scala elision.jar
\family default
.
 If the Scala library is available in 
\family typewriter
scala-library.jar
\family default
 then you can also run it with 
\family typewriter
java -cp scala-library.jar -jar elision.jar
\family default
.
\end_layout

\begin_layout Itemize
To start the REPL from inside a program, invoke the 
\family typewriter
ornl.elision.repl.Repl.run()
\family default
 method.
 This is useful from the Scala prompt, assuming you have the correct 
\family typewriter
CLASSPATH
\family default
.
 You can use the 
\family typewriter
run.sh
\family default
 script found in the Elision root to start Scala with the correct 
\family typewriter
CLASSPATH
\family default
.
\end_layout

\begin_layout Standard
All of these methods will display the Elision banner and present you with
 the REPL prompt 
\family typewriter
e>
\family default
.
 You can enter text to be evaluated as an Elision atom (described in later
 sections), interact with the history (using the up and down arrow keys),
 or edit the current line.
 Pressing Enter submits the line to the Elision parser for evaluation.
\end_layout

\begin_layout Standard
The most useful commands to know immediately are 
\family typewriter
help()
\family default
 (to get help) and 
\family typewriter
:quit
\family default
 (to quit).
\end_layout

\begin_layout Standard
The REPL commands (with the exception of 
\family typewriter
:quit
\family default
 and history recall) are actually Elision operators (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Operators"

\end_inset

).
 As such you must follow them with parentheses; otherwise the Elision REPL
 will interpret them as symbols.
 Try 
\family typewriter
history
\family default
 and then try 
\family typewriter
history()
\family default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
It is permissible to put spaces between the operator name and the opening
 parenthesis: 
\family typewriter
history ()
\family default
.
 This can lead to trouble.
 Suppose you want to have the symbol 
\family typewriter
fred
\family default
 followed by a parenthesized expression: 
\family typewriter
fred (5).$x
\family default
.
 Here the parentheses are necessary to prevent the parser from interpreting
 the dot as a decimal point.
 Unfortunately this will not work the way you might expect.
 The system will parse this as 
\family typewriter
(fred(5)).$x
\family default
.
 To prevent this, put parentheses around 
\family typewriter
fred
\family default
: 
\family typewriter
(fred) (5).$x
\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The REPL reads zero or more atoms per line, evaluates them, and displays
 the output.
 Several atoms can be present on a single line; in that case the REPL displays
 each one.
\end_layout

\begin_layout Standard
Atoms can span multiple lines.
 If a parenthesis, brace, or quotation mark is open at the end of the line,
 then the REPL will prompt for additional input with the prompt 
\family typewriter
>
\family default
.
 The newlines are converted to spaces.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> { operator
\end_layout

\begin_layout Plain Layout

 >   #name=set
\end_layout

\begin_layout Plain Layout

 >   #params=%ACI($P: BOOLEAN, $Q: BOOLEAN)
\end_layout

\begin_layout Plain Layout

 >   #type=BOOLEAN
\end_layout

\begin_layout Plain Layout

 > }
\end_layout

\begin_layout Plain Layout

$_repl0 = {: operator:SYMBOL { binds name -> set:SYMBOL
\end_layout

\begin_layout Plain Layout

  params -> %ACI($P:BOOLEAN, $Q:BOOLEAN) type -> BOOLEAN } :}
\end_layout

\begin_layout Plain Layout

e> "
\end_layout

\begin_layout Plain Layout

 > Fred
\end_layout

\begin_layout Plain Layout

 > "
\end_layout

\begin_layout Plain Layout

$_repl1 = " Fred "
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
History
\end_layout

\begin_layout Standard
The Elision REPL saves a persistent history from session to session.
 This history can be viewed with the 
\family typewriter
history()
\family default
 command.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> history()
\end_layout

\begin_layout Plain Layout

1: {operator #name=test #params=%($x:INTEGER) #type=INTEGER}
\end_layout

\begin_layout Plain Layout

2: {rule add($x,neg($x)) -> 0}
\end_layout

\begin_layout Plain Layout

3: add(21,17,$x)
\end_layout

\begin_layout Plain Layout

4: history()
\end_layout

\begin_layout Plain Layout

Persistent history is found in: /home/userguy/.elision
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is possible to recall any prior history element by entering the history
 index after an exclamation mark.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> !3
\end_layout

\begin_layout Plain Layout

add(21,17,$x)
\end_layout

\begin_layout Plain Layout

$_repl14 = add($x, 38)
\end_layout

\begin_layout Plain Layout

e> bind($x, 2)
\end_layout

\begin_layout Plain Layout

Bound $x
\end_layout

\begin_layout Plain Layout

e> !3
\end_layout

\begin_layout Plain Layout

add(21,17,$x)
\end_layout

\begin_layout Plain Layout

$_repl15 = 40
\end_layout

\begin_layout Plain Layout

e> history()
\end_layout

\begin_layout Plain Layout

1: {operator #name=test #params=%($x:INTEGER) #type=INTEGER}
\end_layout

\begin_layout Plain Layout

2: {rule add($x,neg($x)) -> 0}
\end_layout

\begin_layout Plain Layout

3: add(21,17,$x)
\end_layout

\begin_layout Plain Layout

4: history()
\end_layout

\begin_layout Plain Layout

5: add(21,17,$x)
\end_layout

\begin_layout Plain Layout

6: bind($x, 2)
\end_layout

\begin_layout Plain Layout

7: add(21,17,$x)
\end_layout

\begin_layout Plain Layout

8: history()
\end_layout

\begin_layout Plain Layout

Persistent history is found in: /home/userguy/.elision
\end_layout

\end_inset


\end_layout

\begin_layout Section
Binding
\end_layout

\begin_layout Standard
We can tell the Elision system that we want to replace the variable 
\family typewriter
$x
\family default
 with the value 
\family typewriter
7
\family default
 wherever it appears.
 We say the variable 
\family typewriter
$x
\family default
 is 
\emph on
bound
\emph default
 to 
\family typewriter
7
\family default
, and that the pair 
\family typewriter
$x
\family default
 and 
\family typewriter
7
\family default
 is a 
\emph on
binding
\emph default
, written 
\family typewriter
$x -> 7
\family default
.
 When we replace the variable 
\family typewriter
$x
\family default
 with 
\family typewriter
7
\family default
 in some other term, we say we are 
\emph on
rewriting
\emph default
 the term with the binding.
 The REPL keeps a set of bindings that are used to immediately rewrite any
 atom 
\emph on
after
\emph default
 it is parsed and constructed.
 For instance, if the variable 
\family typewriter
$x
\family default
 is bound to 
\family typewriter
7
\family default
, then entering 
\family typewriter
$x
\family default
 at the prompt results in the value 
\family typewriter
7
\family default
.
 These bindings are stored in the REPL's 
\emph on
context
\emph default
.
 Context atoms are explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Contexts"

\end_inset

; for now you only need to know that the REPL creates and maintains a context
 for you.
\end_layout

\begin_layout Standard
The 
\family typewriter
bind(
\emph on
v
\emph default
,
\emph on
a
\emph default
)
\family default
 command binds a variable 
\family typewriter
\emph on
v
\family default
\emph default
 to an atom 
\family typewriter
\emph on
a
\family default
\emph default
.
 For instance, try 
\family typewriter
bind($x,7)
\family default
 and 
\family typewriter
bind($y,
\backslash
$x.%($x,$x))
\family default
.
 Then try 
\family typewriter
$x
\family default
 and 
\family typewriter
$y
\family default
 at the prompt.
 Then try 
\family typewriter
$y.$x
\family default
.
 Variables can be rebound at any time, and there is no need to 
\begin_inset Quotes eld
\end_inset

unbind
\begin_inset Quotes erd
\end_inset

 them first.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> bind($x,7)
\end_layout

\begin_layout Plain Layout

Bound $x
\end_layout

\begin_layout Plain Layout

e> bind($y,
\backslash
$x.%($x,$x))
\end_layout

\begin_layout Plain Layout

Bound $y
\end_layout

\begin_layout Plain Layout

e> $x
\end_layout

\begin_layout Plain Layout

$_repl16 = 7
\end_layout

\begin_layout Plain Layout

e> $y
\end_layout

\begin_layout Plain Layout

$_repl17 = 
\backslash
$`:1`.%($`:1`, $`:1`)
\end_layout

\begin_layout Plain Layout

e> $y.$x
\end_layout

\begin_layout Plain Layout

$_repl18 = %(7, 7)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
unbind(
\emph on
v
\emph default
)
\family default
 command removes any binding for the variable 
\family typewriter
\emph on
v
\family default
\emph default
.
 Try 
\family typewriter
unbind($x)
\family default
 and then repeat 
\family typewriter
$y.$x
\family default
.
 No error is generated if a variable is not bound.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> unbind($x)
\end_layout

\begin_layout Plain Layout

Unbound $x
\end_layout

\begin_layout Plain Layout

e> $y.$x
\end_layout

\begin_layout Plain Layout

$_repl19 = %($x, $x)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Every time an atom is evaluated by the REPL, the result is displayed and
 then bound to a new variable whose name starts with 
\family typewriter
$_repl
\family default
 followed by a number.
 These variables are displayed on the output.
 Try 
\family typewriter
$_repl1
\family default
.
 Unlike the history, which is persistent between invocations of the REPL,
 these variables are re-started at each session.
\end_layout

\begin_layout Standard
To see all the bindings being used by the shell, enter the command 
\family typewriter
showbinds()
\family default
.
\end_layout

\begin_layout Section
Atom Display
\end_layout

\begin_layout Standard
When you type an atom at the REPL prompt the system parses the atom and
 constructs it.
 Several operators are understood by the REPL, and these are handled immediately.
 Otherwise the current bindings are applied to the atom, and the atom is
 then rewritten using any active rulesets.
 The result of this is then bound to the next 
\family typewriter
$_repl
\family default
\emph on
n
\emph default
 variable.
\end_layout

\begin_layout Standard
You can see the atom after it is parsed and constructed, but before bindings
 are applied and rewriting is performed, by executing the 
\family typewriter
showprior()
\family default
 command.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> bind($x,10)
\end_layout

\begin_layout Plain Layout

Bound $x
\end_layout

\begin_layout Plain Layout

e> showprior()
\end_layout

\begin_layout Plain Layout

Showing prior term is ON.
\end_layout

\begin_layout Plain Layout

e> add($x,$x,0)
\end_layout

\begin_layout Plain Layout

add($x, $x)
\end_layout

\begin_layout Plain Layout

$_repl20 = 20
\end_layout

\begin_layout Plain Layout

e> showprior()
\end_layout

\begin_layout Plain Layout

Showing prior term is OFF.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The atom as entered was 
\family typewriter
add($x,$x,0)
\family default
.
 During construction the identity 
\family typewriter
0
\family default
 is removed, leaving the atom 
\family typewriter
add($x,$x)
\family default
, which is displayed.
 Then the bindings are applied, yielding 
\family typewriter
add(10,10)
\family default
, which is rewritten to 
\family typewriter
20
\family default
 and displayed as the final result.
 Entering 
\family typewriter
showprior()
\family default
 again disables printing the prior atom.
\end_layout

\begin_layout Standard
Most REPL printing can be suppressed using the 
\family typewriter
quiet()
\family default
 command.
 This changes the prompt to 
\family typewriter
q>
\family default
.
 Only explicitly requested output is displayed in this mode.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
It is possible to display the Scala code to create the atom.
 This is enabled (and disabled) with 
\family typewriter
showscala()
\family default
.
 The assumed context for the resulting code is that the content of the 
\family typewriter
core
\family default
 package is imported.
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> showscala()
\end_layout

\begin_layout Plain Layout

Showing Scala is ON.
\end_layout

\begin_layout Plain Layout

e> 
\backslash
$x:$T.$T
\end_layout

\begin_layout Plain Layout

Scala: $_repl28 = Lambda(Variable(Variable(NamedRootType("ANY"), "T", 
\end_layout

\begin_layout Plain Layout

  BooleanLiteral(NamedRootType("BOOLEAN"), true), Set()), ":1", 
\end_layout

\begin_layout Plain Layout

  BooleanLiteral(NamedRootType("BOOLEAN"), true), Set()), 
\end_layout

\begin_layout Plain Layout

  Variable(NamedRootType("ANY"), "T", BooleanLiteral(NamedRootType("BOOLEAN"),
 
\end_layout

\begin_layout Plain Layout

  true), Set()))
\end_layout

\begin_layout Plain Layout

$_repl28 = 
\backslash
$`:1`:$T.$T
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
This can be useful to discover how to construct an atom using the Scala
 API.
\end_layout

\begin_layout Plain Layout
If the above seems excessively complex, 
\emph on
don't panic
\emph default
.
 There are several helpful parts of the API, including implicit conversions,
 to make this all much simpler.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Automatic Rewriting
\end_layout

\begin_layout Standard
Once an atom is entered and bindings are applied, it is rewritten with the
 active rulesets.
 (Applying rules is the subject of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Rules-and-Strategies"

\end_inset

.)
\end_layout

\begin_layout Standard
Rulesets are initially disabled when declared.
 They can be 
\emph on
enabled
\emph default
 using the 
\family typewriter
enable(RS)
\family default
 command, where 
\family typewriter
RS
\family default
 is the name of the ruleset.
 Likewise, they can be 
\emph on
disabled
\emph default
 with the 
\family typewriter
disable(RS)
\family default
 command.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> if (true, 6, 7)
\end_layout

\begin_layout Plain Layout

$_repl19 = if(true, 6, 7)
\end_layout

\begin_layout Plain Layout

e> enable(IF)
\end_layout

\begin_layout Plain Layout

e> if (true, 6, 7)
\end_layout

\begin_layout Plain Layout

$_repl20 = 6
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A limit is placed on the number of times a rule can be applied to rewrite
 an atom.
 This limit can be set via the 
\family typewriter
setlimit(lim)
\family default
 command, where 
\family typewriter
lim
\family default
 is the new limit.
 Automatic rewriting is on by default, but can be disabled (or re-enabled)
 altogether with the 
\family typewriter
rewrite()
\family default
 command.
\end_layout

\begin_layout Standard
You can ask the system which rules may be applied to an atom, using the
 
\family typewriter
showrules(atom)
\family default
 command, where 
\family typewriter
atom
\family default
 is the atom to test.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> showrules(if (true, 6, 7))
\end_layout

\begin_layout Plain Layout

{ RULE if(true, $thenpart, $elsepart) -> $thenpart rulesets IF level 2 }
\end_layout

\begin_layout Plain Layout

{ RULE if(false, $thenpart, $elsepart) -> $elsepart rulesets IF level 2
 } 
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
Understanding Matching
\end_layout

\begin_layout Standard
To support better understanding of the matching process, it is possible
 to enable (or disable) tracing the matching process with the 
\family typewriter
tracematch()
\family default
 command.
 When enabled considerable diagnostic information is printed for every match
 that is attempted.
\end_layout

\begin_layout Standard
Several things trigger the matching system.
 One is constructing an operator application, where arguments are matched
 against the formal parameters.
 Another is matching a lambda argument to the parameter.
 Of course, the most obvious way is by explicitly trying to match two atoms.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> tracematch()
\end_layout

\begin_layout Plain Layout

Match tracing is ON.
\end_layout

\begin_layout Plain Layout

e> 
\backslash
$x:$T.$T.add:OPTYPE
\end_layout

\begin_layout Plain Layout

Sequence Matcher called: $domain,$codomain -> $T,ANY / { bind  }
\end_layout

\begin_layout Plain Layout

TRYING  (cceafb50) in class ornl.elision.core.Variable:
\end_layout

\begin_layout Plain Layout

  pattern: $domain
\end_layout

\begin_layout Plain Layout

  subject: $T
\end_layout

\begin_layout Plain Layout

  with: { bind  }
\end_layout

\begin_layout Plain Layout

SUCCESS (cceafb50): { bind domain -> $T }
\end_layout

\begin_layout Plain Layout

TRYING  (ba5fa5c) in class ornl.elision.core.Variable:
\end_layout

\begin_layout Plain Layout

  pattern: $codomain
\end_layout

\begin_layout Plain Layout

  subject: ANY
\end_layout

\begin_layout Plain Layout

  with: { bind domain -> $T }
\end_layout

\begin_layout Plain Layout

SUCCESS (ba5fa5c): { bind domain -> $T }
\end_layout

\begin_layout Plain Layout

TRYING  (94a4e9fe) in class ornl.elision.core.Lambda$$anon$1:
\end_layout

\begin_layout Plain Layout

  pattern: $`:1`:$T
\end_layout

\begin_layout Plain Layout

  subject: add:OPTYPE
\end_layout

\begin_layout Plain Layout

  with: { bind  }
\end_layout

\begin_layout Plain Layout

Sequence Matcher called: $`::1`,$`::2` -> INTEGER,INTEGER / { bind  }
\end_layout

\begin_layout Plain Layout

TRYING  (e4055fd3) in class ornl.elision.core.Variable:
\end_layout

\begin_layout Plain Layout

  pattern: $`::1`
\end_layout

\begin_layout Plain Layout

  subject: INTEGER
\end_layout

\begin_layout Plain Layout

  with: { bind  }
\end_layout

\begin_layout Plain Layout

SUCCESS (e4055fd3): { bind `::1` -> INTEGER }
\end_layout

\begin_layout Plain Layout

TRYING  (e4055ff2) in class ornl.elision.core.Variable:
\end_layout

\begin_layout Plain Layout

  pattern: $`::2`
\end_layout

\begin_layout Plain Layout

  subject: INTEGER
\end_layout

\begin_layout Plain Layout

  with: { bind `::1` -> INTEGER }
\end_layout

\begin_layout Plain Layout

SUCCESS (e4055ff2): { bind `::1` -> INTEGER, `::2` -> INTEGER }
\end_layout

\begin_layout Plain Layout

Sequence Matcher called: $domain,$codomain -> xx(INTEGER, INTEGER),INTEGER
 / { bind  }
\end_layout

\begin_layout Plain Layout

TRYING  (516c94d7) in class ornl.elision.core.Variable:
\end_layout

\begin_layout Plain Layout

  pattern: $domain
\end_layout

\begin_layout Plain Layout

  subject: xx(INTEGER, INTEGER)
\end_layout

\begin_layout Plain Layout

  with: { bind  }
\end_layout

\begin_layout Plain Layout

SUCCESS (516c94d7): { bind domain -> xx(INTEGER, INTEGER) }
\end_layout

\begin_layout Plain Layout

TRYING  (b28a4874) in class ornl.elision.core.Variable:
\end_layout

\begin_layout Plain Layout

  pattern: $codomain
\end_layout

\begin_layout Plain Layout

  subject: INTEGER
\end_layout

\begin_layout Plain Layout

  with: { bind domain -> xx(INTEGER, INTEGER) }
\end_layout

\begin_layout Plain Layout

SUCCESS (b28a4874): { bind domain -> xx(INTEGER, INTEGER), codomain -> INTEGER
 }
\end_layout

\begin_layout Plain Layout

TRYING  (2b270a36) in class ornl.elision.core.Variable:
\end_layout

\begin_layout Plain Layout

  pattern: $T
\end_layout

\begin_layout Plain Layout

  subject: MAP(xx(INTEGER, INTEGER), INTEGER)
\end_layout

\begin_layout Plain Layout

  with: { bind  }
\end_layout

\begin_layout Plain Layout

SUCCESS (2b270a36): { bind T -> MAP(xx(INTEGER, INTEGER), INTEGER) }
\end_layout

\begin_layout Plain Layout

SUCCESS (94a4e9fe): { bind `:1` -> add:OPTYPE, T -> MAP(xx(INTEGER, INTEGER),
 INTEGER) }
\end_layout

\begin_layout Plain Layout

$_repl21 = MAP(xx(INTEGER, INTEGER), INTEGER)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Reading this trace can be tricky.
 The sequence matcher tries to perform an in-order pairwise match of two
 sequences of atoms, given some set of bindings.
 For example, the first line indicates that the sequence matcher was called
 to match the pattern sequence 
\family typewriter
$domain,$codomain
\family default
 against the subject sequence 
\family typewriter
$T,ANY
\family default
 with no prior bindings.
\end_layout

\begin_layout Standard
The lines that begin with 
\family typewriter
TRYING
\family default
 and 
\family typewriter
SUCCESS
\family default
 or 
\family typewriter
FAILURE
\family default
 are linked using the hexadecimal number in parentheses.
 This number is actually a hash code for the match attempt and serves to
 link together the lines.
 In a large match attempts will often interleave.
\end_layout

\begin_layout Standard
Following a 
\family typewriter
TRYING
\family default
 line the pattern, subject, and any bindings are printed.
 On 
\family typewriter
SUCCESS
\family default
 we see the bindings that result in a successful match.
 On 
\family typewriter
FAILURE
\family default
 we are told why the match failed, and the pattern and subject may be repeated.
\end_layout

\begin_layout Standard
In some cases there will be additional matching reports after the 
\family typewriter
$_repl
\family default
 result is shown.
 These are due to 
\emph on
round-trip testing
\emph default
 by the system.
\begin_inset Foot
status open

\begin_layout Plain Layout
This testing is used to assure 
\emph on
referential transparency
\emph default
, and can be disabled using the 
\family typewriter
setroundtrip(false)
\family default
 command.
\end_layout

\end_inset

 This is testing that determines whether or not an atom's representation
 can be successfully re-parsed to yield the original atom, and this output
 can safely be ignored.
 Look for the line beginning with 
\family typewriter
$_repl
\family default
 and ignore subsequent output.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> {match 7}.$x
\end_layout

\begin_layout Plain Layout

TRYING  (de6d60a9) in class ornl.elision.core.IntegerLiteral:
\end_layout

\begin_layout Plain Layout

  pattern: 7
\end_layout

\begin_layout Plain Layout

  subject: $x
\end_layout

\begin_layout Plain Layout

  with: { bind  }
\end_layout

\begin_layout Plain Layout

TRYING  (493d55a8) in class ornl.elision.core.INTEGER$:
\end_layout

\begin_layout Plain Layout

  pattern: INTEGER
\end_layout

\begin_layout Plain Layout

  subject: ANY
\end_layout

\begin_layout Plain Layout

  with: { bind  }
\end_layout

\begin_layout Plain Layout

SUCCESS (493d55a8): { bind  }
\end_layout

\begin_layout Plain Layout

FAILURE (de6d60a9): Literal pattern does not match subject.
\end_layout

\begin_layout Plain Layout

  pattern: 7
\end_layout

\begin_layout Plain Layout

  subject: $x
\end_layout

\begin_layout Plain Layout

$_repl41 = Nothing:ANY
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For this simple example we see the inner attempt to match the types succeeds,
 and then the outer attempt to match the entire atoms fails because 
\family typewriter
7
\family default
 is a literal pattern and it can only match another literal 
\family typewriter
7
\family default
.
\end_layout

\begin_layout Section
Understanding Parsing
\end_layout

\begin_layout Standard
The parser can also be traced, and this results in an enormous quantity
 of output.
 To enable (or disable) parser tracing, use the 
\family typewriter
traceparse()
\family default
 command.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> traceparse()
\end_layout

\begin_layout Plain Layout

Parser tracing is ON.
\end_layout

\begin_layout Plain Layout

e> 7
\end_layout

\begin_layout Plain Layout

Starting new parsing run
\end_layout

\begin_layout Plain Layout

a sequence of atoms/ZeroOrMore/AtomSeqPush1Action1, matched, cursor at 1:1
 after ""
\end_layout

\begin_layout Plain Layout

..(1)../ZeroOrMore/ZeroOrMore/Sequence/an atom/LApply/a simple atom/whitespace
 or
\end_layout

\begin_layout Plain Layout

comments/FirstOf/OneOrMore/[ 
\backslash
n
\backslash
r
\backslash
t
\backslash
f], failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(9)../OneOrMore, failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(8)../FirstOf/Sequence/"/*", failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(9)../Sequence, failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(8)../FirstOf/Sequence/"//", failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(9)../Sequence, failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(8)../FirstOf, failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(7)../whitespace or comments, matched, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(6)../a simple atom/FirstOf/Sequence/'(', failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(8)../Sequence, failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(7)../FirstOf/a ruleset declaration/'{', failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(8)../a ruleset declaration, failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(7)../FirstOf/a rewrite rule/'{', failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

..(8)../a rewrite rule, failed, cursor at 1:1 after ""
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

..(3)../Sequence, failed, cursor at 1:2 after "7"
\end_layout

\begin_layout Plain Layout

..(2)../FirstOf/Sequence/"//", failed, cursor at 1:2 after "7"
\end_layout

\begin_layout Plain Layout

..(3)../Sequence, failed, cursor at 1:2 after "7"
\end_layout

\begin_layout Plain Layout

..(2)../FirstOf, failed, cursor at 1:2 after "7"
\end_layout

\begin_layout Plain Layout

..(1)../whitespace or comments, matched, cursor at 1:2 after "7"
\end_layout

\begin_layout Plain Layout

a sequence of atoms/EOI, matched, cursor at 1:3 after "7"
\end_layout

\begin_layout Plain Layout

a sequence of atoms, matched, cursor at 1:3 after "7"
\end_layout

\begin_layout Plain Layout

$_repl14 = 7
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Many, many lines are omitted from the above.
 The number shows the depth of the parse which, for this example, reaches
 16.
 Note that, as with match tracing, the round trip testing results in additional
 output that can be ignored.
\end_layout

\begin_layout Chapter
Basic Atoms
\end_layout

\begin_layout Standard
The objects manipulated by Elision are called 
\emph on
atoms
\emph default
, and they exist in several forms.
\end_layout

\begin_layout Itemize

\emph on
Literals
\emph default
 that denote a simple, fixed value.
\end_layout

\begin_layout Itemize

\emph on
Variables
\emph default
 denote an unspecified atom, perhaps with type information.
\end_layout

\begin_layout Itemize

\emph on
Lambdas
\emph default
 denote simple unnamed functions of one parameter.
\end_layout

\begin_layout Itemize

\emph on
Applies
\emph default
 denote an ordered pair consisting of a left-hand element often called the
 
\emph on
operator
\emph default
 and a right-hand element often called the 
\emph on
argument
\emph default
.
\end_layout

\begin_layout Itemize

\emph on
Operators
\emph default
 denote a mapping.
\end_layout

\begin_layout Itemize

\emph on
Rewriters
\emph default
 transform an atom into a potentially new form, reporting whether this transform
ation succeeded.
\end_layout

\begin_layout Standard
Atoms can be combined to make composite atoms
\begin_inset Foot
status open

\begin_layout Plain Layout
No, not molecules.
 This is not chemistry.
\end_layout

\end_inset

 in a variety of ways.
 These are discussed in the following sections and chapters.
\end_layout

\begin_layout Section
Types
\end_layout

\begin_layout Standard
Every atom has an associated 
\emph on
type
\emph default
, which is itself just another atom.
 Since every atom has a type, and every type is an atom, we have a potential
 infinite regress.
 To avoid this the special 
\emph on
type universe
\emph default
 atom, denoted 
\family typewriter
^TYPE
\family default
, is its own type.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
As has been pointed out, 
\begin_inset Quotes eld
\end_inset

it's turtles all the way down.
\begin_inset Quotes erd
\end_inset

 
\family typewriter
^TYPE
\family default
 is the turtle that stands on its own head.
\end_layout

\end_inset

 The fact that atom 
\begin_inset Formula $a$
\end_inset

 has type 
\begin_inset Formula $T$
\end_inset

 is denoted by joining the atom and its type with a colon: 
\begin_inset Formula $a:T$
\end_inset

.
 The type colon is right associative, so 
\begin_inset Formula $a:B:C$
\end_inset

 denotes 
\begin_inset Formula $a:(B:C)$
\end_inset

.
 In fact, this is the only way the colon can work.
 Since an atom has exactly one type, 
\begin_inset Formula $(a:B):C$
\end_inset

 is effectively meaningless, and generates an error in Elision.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Every atom is an instance of a class extending 
\family typewriter
core.BasicAtom
\family default
.
 All atoms are immutable after construction.
 The type of an atom must be specified at construction time, and can be
 accessed later via the public field 
\family typewriter
theType
\family default
.
 The type universe can be accessed in two ways: 
\family typewriter
core.TypeUniverse
\family default
 is a singleton implementing the type universe, and it can be accessed via
 the alias 
\family typewriter
`^TYPE`
\family default
 provided by the 
\family typewriter
core
\family default
 package.
 Back ticks must be used since 
\family typewriter
^TYPE
\family default
 is not a valid Scala symbol.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Literals
\end_layout

\begin_layout Standard
Elision directly supports several kinds of literals.
 These are indivisible, simple-valued atoms.
\end_layout

\begin_layout Subsection
Symbols
\end_layout

\begin_layout Standard
Symbols start with an underscore or letter, followed by any number of letters,
 digits, and underscores.
 The following are legal symbol literals.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="4">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
A
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
x
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
_21
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Fred21
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Other characters may occur in symbols, but the entire symbol must be enclosed
 in back ticks, which are not themselves part of the symbol.
 Several escape sequences are interpreted; these are listed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Escape-Codes"

\end_inset

.
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Escape-Codes"

\end_inset

Escape Codes
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
f
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Form Feed Character
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
n
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Newline
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
r
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Carriage Return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
t
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tab Character
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
`
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Back tick
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash

\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Double Quotation Mark
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash

\backslash

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Backslash
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset

 Using the back tick notation the following are also legal symbol literals.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="4">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
`1`
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
`$_4`
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
`
\backslash
`Fred
\backslash
``
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
``
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Symbols are created via the 
\family typewriter
core.Literal(sym)
\family default
 method, where 
\family typewriter
sym
\family default
 is a Scala symbol.
\end_layout

\begin_layout Plain Layout
Take care! Scala symbols are automatically converted to Elision 
\emph on
variables
\emph default
, not symbol literals, when used in a context expecting an Elision atom.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Strings
\end_layout

\begin_layout Standard
A string is a sequence of characters enclosed in double quotation marks,
 which are not themselves part of the symbol.
 As with back-tick-quoted symbols, escape codes are interpreted in the string.
 The escape codes are listed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Escape-Codes"

\end_inset

.
 The following are legal string literals.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="4">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
""
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
"Fred"
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
"`21,` she said."
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
"
\backslash
"Yes,
\backslash
" he replied."
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Elision also provides for verbatim blocks, which evaluate to strings.
 A verbatim block is indicated by any arbitrary text enclosed within triple
 quotation mark pairs.
 All characters are preserved as-is, and the result of evaluation is a string
 literal.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> """
\end_layout

\begin_layout Plain Layout

 > This is a multiline string literal.
\end_layout

\begin_layout Plain Layout

 > Note that 
\backslash
 is left untouched."""
\end_layout

\begin_layout Plain Layout

$_repl3 = "
\backslash
nThis is a multiline string literal.
\backslash
nNote that 
\backslash

\backslash
 is left untouched." 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Strings are created via the 
\family typewriter
core.Literal(str)
\family default
 method, where 
\family typewriter
str
\family default
 is a Scala string.
\end_layout

\begin_layout Plain Layout
Scala strings are automatically converted to Elision string literals as
 necessary.
 Thus it is possible to pass 
\family typewriter
"$"
\family default
 to a method expecting an Elision atom.
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> "I'm a string":BasicAtom
\end_layout

\begin_layout Plain Layout

res0: ornl.elision.core.BasicAtom = StringLiteral(NamedRootType("STRING"),
\end_layout

\begin_layout Plain Layout

"I'm a string") 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Numbers
\end_layout

\begin_layout Standard
Numbers may be expressed in binary, octal, decimal, or hexadecimal (the
 
\emph on
radix
\emph default
).
 Binary numbers are indicated by the prefix 
\family typewriter
0b
\family default
, octal numbers are indicated by a leading 
\family typewriter
0
\family default
, decimal numbers are indicated by a leading non-zero digit, and hexadecimal
 numbers are indicated by the prefix 
\family typewriter
0x
\family default
.
 The prefixes are 
\emph on
not
\emph default
 case-sensitive.
\end_layout

\begin_layout Standard
Floating point numbers are also supported in binary, octal, decimal, and
 hexadecimal, and are indicated either by a decimal point, an exponent,
 or both.
 The exponent is typically indicated by an 
\family typewriter
e
\family default
, must be an integer, and may be in a different radix.
 Because 
\family typewriter
e
\family default
 is a valid hexadecimal digit, 
\family typewriter
p
\family default
 may also be used to indicate an exponent (and must be for hexadecimal numbers).
 Numbers are 
\emph on
not
\emph default
 case sensitive.
 If a floating point number consists of significand 
\begin_inset Formula $s$
\end_inset

, exponent 
\begin_inset Formula $e$
\end_inset

, and radix 
\begin_inset Formula $r$
\end_inset

, then the number denoted is given by the following equation.
\begin_inset Formula 
\[
s\times r^{e}
\]

\end_inset


\end_layout

\begin_layout Standard
The following are legal number literals.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
-1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
05743645134635
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
-0x232
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
2.5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0b10.1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0x2.8
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
02.4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
21e-6
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0b10101e-0b110
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0x15p-0x6
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
025e-06
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
Keep in mind that the radix of the significand and the exponent must both
 be specified.
\end_layout

\begin_layout Standard
The number undergoes a conversion to place it in a consistent radix.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This conversion takes place during parsing.
\end_layout

\end_inset

 This conversion is performed as follows.
 Let the number be 
\begin_inset Formula $i.f\mathtt{e}e$
\end_inset

, where 
\begin_inset Formula $i$
\end_inset

 is the integer portion of the significand, 
\begin_inset Formula $f$
\end_inset

 is the fractional portion of the significand, and 
\begin_inset Formula $e$
\end_inset

 is the exponent.
 We note that 
\begin_inset Formula $i.f$
\end_inset

 is in one radix, which we denote 
\begin_inset Formula $r$
\end_inset

, and the exponent may be in a different radix.
 If the length of 
\begin_inset Formula $f$
\end_inset

 is 
\begin_inset Formula $|f|$
\end_inset

, then the entire significand is multiplied by 
\begin_inset Formula $r^{|f|}$
\end_inset

 to convert it to an integer.
 The exponent is then converted to radix 
\begin_inset Formula $r$
\end_inset

, yielding 
\begin_inset Formula $e'$
\end_inset

, and 
\begin_inset Formula $|f|$
\end_inset

 is subtracted from it.
\begin_inset Formula 
\[
n=i.f\mathtt{e}e=(i.f)r^{|f|}\mathtt{e}(e'-|f|)
\]

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Integers are created via the 
\family typewriter
core.Literal(i)
\family default
 method, where 
\family typewriter
i
\family default
 is a Scala 
\family typewriter
BigInt
\family default
.
 Floating point numbers can be created via the 
\family typewriter
core.Literal(FLOAT,sig,exp,rad)
\family default
 method, where 
\family typewriter
sig
\family default
 is the significand (a Scala 
\family typewriter
BigInt
\family default
), 
\family typewriter
exp
\family default
 is the exponent (a Scala 
\family typewriter
Int
\family default
), and 
\family typewriter
rad
\family default
 is the radix (one of 2, 8, 10, or 16).
\end_layout

\begin_layout Plain Layout
Scala 
\family typewriter
Int
\family default
 and 
\family typewriter
BigInt
\family default
 are automatically converted to Elision integer literals as necessary.
 Thus it is possible to pass 
\family typewriter
17
\family default
 to a method expecting an Elision atom.
\end_layout

\begin_layout Plain Layout
If you have a floating point literal, you can obtain its value as a Scala
 float with 
\family typewriter
toFloat
\family default
 and as a Scala double with 
\family typewriter
toDouble
\family default
.
 You can also convert it to radix two using 
\family typewriter
toBinary
\family default
.
 Because this changes the base of a floating point number you may lose precision.
\end_layout

\begin_layout Plain Layout
At present Elision does not support the positive or negative infinity or
 the signaling or quiet NaN.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Booleans
\end_layout

\begin_layout Standard
Boolean literals come in two forms: 
\family typewriter
true
\family default
 and 
\family typewriter
false
\family default
.
 Both have the type 
\family typewriter
BOOLEAN
\family default
.
 If you want an Elision symbol named 
\family typewriter
true
\family default
 or 
\family typewriter
false
\family default
, you must override the type, and write 
\family typewriter
true:SYMBOL
\family default
, for instance.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
The Boolean literals can be obtained as 
\family typewriter
Literal.TRUE
\family default
 and 
\family typewriter
Literal.FALSE
\family default
.
 Scala Booleans are automatically converted to Elision Boolean literals
 as necessary.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Special Symbols
\end_layout

\begin_layout Standard
Certain symbols are interpreted differently from others.
 Three have already been discussed: 
\family typewriter
^TYPE
\family default
 denoting the type universe, 
\family typewriter
true
\family default
, and 
\family typewriter
false
\family default
.
 Others denote named root types.
 A 
\emph on
root atom
\emph default
 is an atom whose type is 
\family typewriter
^TYPE
\family default
.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Special-Root-Type"

\end_inset

 lists the named root atoms declared by the current system.
 These are typically used as types, so they are often called 
\emph on
root types
\emph default
.
 Two of these: 
\family typewriter
OPREF
\family default
 and 
\family typewriter
RSREF
\family default
 exist to cause the system to 
\begin_inset Quotes eld
\end_inset

look up
\begin_inset Quotes erd
\end_inset

 a name in the current context.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Special-Root-Type"

\end_inset

Special Root Type Symbols
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Elision Symbol
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interpretation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ANY
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The wildcard.
 The special atom denoting anything.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
BINDING
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The root type for all bindings.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
BOOLEAN
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The root type for all Booleans.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
FLOAT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The root type for all floating point numbers.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
INTEGER
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The root type for all integer numbers.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
NONE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The special atom denoting nothing.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
OPREF
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A root type for indicating that a symbol denotes an operator.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
RSREF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A root type for indicating that a symbol denotes a ruleset.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
STRATEGY
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The root type for all strategies and rewrite rules.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
STRING
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The root type for all strings.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
SYMBOL
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The root type for all symbols.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The special atom 
\family typewriter
ANY
\family default
 matches any atom, and any atom matches it, so it can be treated as a wildcard
 during matching, and is also the assumed type of otherwise untyped atoms.
 
\family typewriter
ANY
\family default
 is unusual; it violates the substitution principle (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Matching-and-Rewriting"

\end_inset

).
 
\family typewriter
ANY
\family default
 matches 
\family typewriter
NONE
\family default
, but 
\family typewriter
NONE
\family default
 matches only itself.
\end_layout

\begin_layout Standard
Untyped symbols not in the above list have the assumed type 
\family typewriter
SYMBOL
\family default
.
 If you want an ordinary symbol counterpart to any of the above, you must
 explicitly ask for it.
 For example, if you want the ordinary symbol 
\family typewriter
STRATEGY
\family default
, you must use 
\family typewriter
STRATEGY:SYMBOL
\family default
.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
All the symbols listed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Special-Root-Type"

\end_inset

 are also Scala objects that extend 
\family typewriter
core.NamedRootType
\family default
.
 They can be used directly, so 
\family typewriter
SYMBOL
\family default
 is a Scala value denoting the Elision 
\family typewriter
SYMBOL
\family default
 type.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Variables
\end_layout

\begin_layout Standard
Variables are indicated by a leading dollar sign followed by the variable
 name, which is parsed as a symbol.
 The following are legal variables.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="4">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
$x
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
$_21
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
$`1`
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
$`$_4`
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Variables are looked up by name, but matched by 
\emph on
both
\emph default
 name and type.
 This means that you should never use the same variable name with different
 types in a single atom, as it will break matching in unusual ways.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is not an attempt to be frustrating.
 It is a performance issue.
 Under the hood, bindings are stored in a hash table indexed by the interned
 variable name.
 This makes lookup faster than if we had to check for an equal name and
 type.
\end_layout

\end_inset

 If no type is specified for a variable, Elision assigns it the special
 root type 
\family typewriter
ANY
\family default
.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Variables are created using 
\family typewriter
core.Variable(typ,name)
\family default
, where 
\family typewriter
typ
\family default
 is the variable type, and 
\family typewriter
name
\family default
 is the variable name.
 Thus the Elision variable 
\family typewriter
$x:INTEGER
\family default
 can be created with 
\family typewriter
Variable(INTEGER,"x")
\family default
.
 Scala symbols are also automatically converted to variables of type 
\family typewriter
ANY
\family default
, so it is possible to pass a Scala symbol to methods expecting an atom.
 Thus 
\family typewriter
$x:ANY
\family default
 can also be written (depending on context) as 
\family typewriter
'x
\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Lambdas"

\end_inset

Lambdas
\end_layout

\begin_layout Standard
A lambda expression denotes a function with a single parameter, and consists
 of a variable called the 
\emph on
lambda parameter
\emph default
 and an atom called the 
\emph on
body
\emph default
.
 The lambda is 
\emph on
evaluated
\emph default
 (or 
\emph on
curried
\emph default
) by applying it to another atom, called the 
\emph on
argument
\emph default
, and then replacing instances of the lambda parameter in the body with
 the argument.
 This is all much simpler than it sounds.
\end_layout

\begin_layout Standard
Lambdas are introduced by a backslash (
\family typewriter

\backslash

\family default
) followed by the parameter (a variable), then a dot (
\family typewriter
.
\family default
), and then the body (an atom).
 The following is a lambda that denotes a constant function whose value
 is 7 no matter what argument is provided.
\end_layout

\begin_layout LyX-Code

\backslash
$x.7
\end_layout

\begin_layout Standard
The following denotes the identity function that returns the atom it is
 applied to.
\begin_inset Foot
status open

\begin_layout Plain Layout
This is sometimes called the 
\emph on
I combinator
\emph default
.
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\backslash
$x.$x
\end_layout

\begin_layout Standard
The following is a lambda that creates constant functions.
\begin_inset Foot
status open

\begin_layout Plain Layout
This also has a catchy name: it is the 
\emph on
K combinator
\emph default
.
\end_layout

\end_inset

 When applied to an argument, the result is a function that always returns
 that argument.
\end_layout

\begin_layout LyX-Code

\backslash
$x.
\backslash
$y.$x
\end_layout

\begin_layout Standard
To apply a lambda to an atom, join the lambda and the atom with a dot (
\family typewriter
.
\family default
).
 The lambda dot binds more tightly than the application dot.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Lambdas"

\end_inset

 shows some examples of lambda applications and the results.
 The parentheses around the 7 in the first entry are required to prevent
 the system from seeing 7.12 as a floating point number.
\end_layout

\begin_layout Standard
Consider the last item in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Lambdas"

\end_inset

.
 We move through this step-by-step to show what is going on here.
 First, let's parenthesize this to better see the pieces: 
\family typewriter
(
\backslash
$x.(
\backslash
$y.$x)).12
\family default
.
 Now we see that we have a lambda expression of the form 
\family typewriter

\backslash
$x.
\family default

\begin_inset Formula $b$
\end_inset


\family typewriter
.12
\family default
, where 
\begin_inset Formula $b$
\end_inset

 is the lambda body.
 This says to replace 
\family typewriter
$x
\family default
 with 
\family typewriter
12
\family default
 in the body.
 Replacing 
\family typewriter
$x
\family default
 with 
\family typewriter
12
\family default
 in the body (
\family typewriter
$y.$x
\family default
) gives 
\family typewriter
$y.12
\family default
, which is the answer.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Lambdas"

\end_inset

Lambdas
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lambda Expression
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$x.(7).12
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$x.$x.12
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$x.
\backslash
$y.$x.12
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$y.12
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you enter 
\family typewriter

\backslash
$x.
\backslash
$y.$x.12
\family default
 at the Elision prompt, you will 
\emph on
not
\emph default
 see 
\family typewriter

\backslash
$y.12
\family default
.
 What you 
\emph on
will
\emph default
 see is 
\family typewriter

\backslash
$`:1`.12
\family default
.
 The 
\family typewriter
$y
\family default
 has been replaced with the funny variable 
\family typewriter
$`:1`
\family default
.
 This variable is a DeBruijn index, and it is used to prevent lambdas from
 
\begin_inset Quotes eld
\end_inset

capturing
\begin_inset Quotes erd
\end_inset

 variables.
 In practice you should not need to worry about DeBruijn indices; the system
 uses them when appropriate and keeps track of the details for you.
 If you are curious, please see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:De-Bruijn-Indices"

\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
For reasons now obvious, you should avoid variable names that start with
 colons.
 Elision uses these internally, and not just for DeBruijn indices, but also
 for 
\begin_inset Quotes eld
\end_inset

synthetic
\begin_inset Quotes erd
\end_inset

 rules and 
\begin_inset Quotes eld
\end_inset

synthetic
\begin_inset Quotes erd
\end_inset

 parameters created during matching.
 Partial rule completion is explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Rules-and-Strategies"

\end_inset

 and matching is explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Matching-and-Rewriting"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A lambda parameter is 
\emph on
matched
\emph default
 against the argument, and the result is used to 
\emph on
rewrite
\emph default
 the body.
 This is all explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Matching-and-Rewriting"

\end_inset

, but in practice it means that if you specify the type of the parameter,
 then Elision will enforce this.
 Thus the lambda expression 
\family typewriter

\backslash
$x:INTEGER.$x.7
\family default
 will succeed with the value 7, while the lambda expression 
\family typewriter

\backslash
$x:INTEGER.$x."Fred"
\family default
 will fail with an error.
 This also means that the type of an atom can be extracted using a lambda.
 The following lambda will extract the type of any atom it is applied to.
\end_layout

\begin_layout LyX-Code

\backslash
$x:$T.$T
\end_layout

\begin_layout Standard
Thus the expression 
\family typewriter

\backslash
$x:$T.$T."Fred"
\family default
 evaluates to 
\family typewriter
STRING
\family default
.
\end_layout

\begin_layout Standard
The applicative dot binds right to left.
 For this reason, multiple parameter lambda expressions 
\emph on
may
\emph default
 need to be parenthesized when applied.
 Consider the following example.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> 
\backslash
$first.
\backslash
$second.%($first,$second).(2).(1)
\end_layout

\begin_layout Plain Layout

$_repl14 = %(2, 1)
\end_layout

\begin_layout Plain Layout

e> 
\backslash
$first.(
\backslash
$second.%($first,$second).2).(1)
\end_layout

\begin_layout Plain Layout

$_repl15 = %(1, 2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So what happened? The lambda dot binds more tightly than the applicative
 dot, and the applicative dot binds to the left, so in the first line the
 
\family typewriter
2
\family default
 become the argument to 
\family typewriter

\backslash
$first.
\backslash
$second.%($first,$second)
\family default
.
 This is rewritten to 
\family typewriter

\backslash
$second.%(2,$second)
\family default
.
 Parentheses in the second line force 
\family typewriter
2
\family default
 to be bound in the inner lambda first.
 This binding order was chosen so that arguments can, in the unparenthesized
 case, be given in the same order (left to right) as the parameters to which
 they bind.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
To create a lambda use 
\family typewriter
core.Lambda(param,body)
\family default
, where 
\family typewriter
param
\family default
 is the lambda parameter and 
\family typewriter
body
\family default
 is the lambda body.
 To apply a lambda to an argument, use 
\family typewriter
core.Apply(lambda,arg)
\family default
, where 
\family typewriter
lambda
\family default
 is the lambda expression and 
\family typewriter
arg
\family default
 is the argument.
 The following shows how several lambda expressions can be created in Scala.
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lambda Expression
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Scala Code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$x.7
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Lambda('x,7)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$x.$x
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Lambda('x,'x)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$x.
\backslash
$y.$x
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Lambda('x,Lambda('y,'x))
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$x:INTEGER.$x.7
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Apply(Lambda(Variable(INTEGER,"x"),'x),7)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter

\backslash
$x:$T.$T."Fred"
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Apply(Lambda(Variable('T,"x"),'T),"Fred")
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Lists"

\end_inset

Collections
\end_layout

\begin_layout Standard
Elision provides a generalized collection type called, for lack of a better
 name, an 
\emph on
atom sequence
\emph default
.
 In its 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 form it is an ordered list of atoms, but this can be changed in a variety
 of ways by specifying the algebraic properties of the collection.
\end_layout

\begin_layout Section
The Basic Ordered Sequence
\end_layout

\begin_layout Standard
A basic ordered sequence of atoms is represented by a comma-separated list
 of atoms, enclosed in parentheses, and prefixed with a percent sign (
\family typewriter
%
\family default
).
 This 
\begin_inset Quotes eld
\end_inset

looks like
\begin_inset Quotes erd
\end_inset

 a 
\family typewriter
%
\family default
 operator applied to a list of atoms.
 For instance the list 
\family typewriter
1
\family default
 followed by 
\family typewriter
2
\family default
 can be represented with 
\family typewriter
%(1,2)
\family default
.
 Empty sequences are permissible, too: 
\family typewriter
%()
\family default
.
\end_layout

\begin_layout Standard
The collection can be heterogeneous.
 For instance 
\family typewriter
%(1,"Fred")
\family default
 is perfectly fine.
 The type of a collection is deduced by looking at the types of the contained
 elements.
 If they all have the same type 
\begin_inset Formula $T$
\end_inset

, then the type is 
\family typewriter
SEQ(
\family default

\begin_inset Formula $T$
\end_inset


\family typewriter
)
\family default
.
 If any has a different type, then the type of the collection is 
\family typewriter
SEQ(ANY)
\family default
.
\end_layout

\begin_layout Section
Algebraic Properties
\end_layout

\begin_layout Standard
Algebraic properties can be assigned to the sequence, and are specified
 starting with a percent sign.
 Actually, the leading percent sign for the basic ordered sequence is itself
 an algebraic properties specification, albeit a very simple one.
 Several properties are available, and the properties can even be 
\begin_inset Quotes eld
\end_inset

detached
\begin_inset Quotes erd
\end_inset

 from the sequence, matched, and rewritten.
 That is, an algebraic property specification is an atom on its own.
 Algebraic properties specifications look like operators, and even behave
 a bit like operators.
\end_layout

\begin_layout Standard
Each available property is described in more detail in the following subsections.
 Properties are specified by a single character, which is 
\emph on
not
\emph default
 case-sensitive, and can be negated by prefixing with an exclamation mark
 (
\family typewriter
!
\family default
).
 Properties are combined by juxtaposing them, and omitting a property altogether
 leaves it unspecified.
 The following table is a quick reference to the properties.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Algebraic Properties
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Property
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Character
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Can Be Negated
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requires an Argument
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Associativity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Commutativity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Idempotency
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Absorber
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Properties may be given an argument in square brackets.
 For absorbers and identities, this will be the appropriate atom.
 For associativity, commutativity, and idempotency, this is typically either
 a Boolean literal or a variable for matching.
 The sense of the Boolean represents whether the property is present, so
 
\family typewriter
A
\family default
 alone is the same as 
\family typewriter
A[true]
\family default
, and 
\family typewriter
!A
\family default
 is the same as 
\family typewriter
A[false]
\family default
.
\end_layout

\begin_layout Standard
The order of properties is not significant, and conflicts are resolved with
 the last property specification winning.
 Thus 
\family typewriter
%AA!A
\family default
 is the same as 
\family typewriter
%!A
\family default
.
 Spaces are only permitted in the arguments to a property (inside the square
 brackets).
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Operator properties are specified by 
\family typewriter
core.AlgProp
\family default
.
 This class can be used directly, but it is typically easier to use its
 extensions: 
\family typewriter
Associative(bool)
\family default
, 
\family typewriter
Commutative(bool)
\family default
, 
\family typewriter
Idempotent(bool)
\family default
, 
\family typewriter
Absorber(atom)
\family default
, and 
\family typewriter
Identity(atom)
\family default
.
 The first three take a Boolean value, and the last two take an atom.
 Join these with 
\family typewriter
and
\family default
.
 The following builds the properties specification for integer addition,
 which is associative, commutative, not idempotent, and has an identity
 of zero.
\end_layout

\begin_layout LyX-Code
Associative(true) and Commutative(true) and Idempotent(false) and Identity(0)
\end_layout

\begin_layout Plain Layout
There is also an extension 
\family typewriter
NoProps
\family default
 that indicates no properties.
 This is useful if you don't care to specify any properties.
 Note that leaving a property unspecified is not the same as negating it;
 it just leaves the property unspecified.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Associativity
\end_layout

\begin_layout Standard
An associative collection can have its elements grouped arbitrarily, provided
 the subgroups have the same algebraic properties specification.
 Associative collections are indicated with the symbol 
\family typewriter
A
\family default
.
 Thus we have 
\family typewriter
%A(5,2,%A(3,4),1)
\family default
 is the same as 
\family typewriter
%A(5,2,3,4,1)
\family default
.
 In fact, Elision will convert the former to the latter.
\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> %A(5,2,%A(3,4),1)
\end_layout

\begin_layout Plain Layout

$_repl0 = %A(5, 2, 3, 4, 1)
\end_layout

\begin_layout Plain Layout

e> %A(5,2,%(3,4),1)
\end_layout

\begin_layout Plain Layout

$_repl1 = %A(5, 2, %(3, 4), 1)
\end_layout

\end_inset

In the second line the properties specifications do not match, so Elision
 does not flatten the elements.
\end_layout

\begin_layout Subsection
Commutativity
\end_layout

\begin_layout Standard
A commutative collection can have its arguments re-ordered arbitrarily.
 Commutative collections are indicated with the symbol 
\family typewriter
C
\family default
.
 Thus 
\family typewriter
%C(1,2,3)
\family default
 is the same as 
\family typewriter
%C(3,2,1)
\family default
.
\end_layout

\begin_layout Subsection
Idempotency
\end_layout

\begin_layout Standard
An idempotent collection ignores element multiplicity.
 This is a complicated way of saying repeated elements do not matter.
 Idempotent collections are indicated with the symbol 
\family typewriter
I
\family default
.
 Thus 
\family typewriter
%I(1,2,2,3)
\family default
 is the same as 
\family typewriter
%I(1,2,3)
\family default
.
 In fact, Elision will discard repeated elements.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> %I(1,2,2,3)
\end_layout

\begin_layout Plain Layout

$_repl2 = %I(1, 2, 3)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Identity
\end_layout

\begin_layout Standard
A special element may be designated as the identity.
 Including the identity in the sequence does not change its meaning.
 In fact, Elision will discard instances of the identity from the collection.
 An identity is indicated by the character 
\family typewriter
D
\family default
 followed by the identity element in square brackets.
 Thus 
\family typewriter
%D(1,0,0,3)
\family default
 is the same as 
\family typewriter
%(1,3)
\family default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> %D[0](1,0,0,3)
\end_layout

\begin_layout Plain Layout

$_repl3 = %D[0](1, 3)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Absorber
\end_layout

\begin_layout Standard
Similar to an identity, a special element may be designated as an absorber.
 If an absorber is present, the meaning is the same as if 
\emph on
only
\emph default
 the absorber were present.
 Because of this, if Elision finds an absorber it dicards everything else
 (including other instances of the absorber) from the collection.
 An absorber is indicated by the character 
\family typewriter
B
\family default
 followed by the absorber element in square brackets.
 Thus 
\family typewriter
%B[0](1,0,0,3)
\family default
 is the same as 
\family typewriter
%B[0](0)
\family default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Yes, you can designate the same atom as both an identity and an absorber,
 but why? You will get a collection consisting of exactly one instance of
 the absorber, as absorber processing takes precedence.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> %B[0](1,0,0,3)
\end_layout

\begin_layout Plain Layout

$_repl4 = %B[0](0)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Simple Collections
\end_layout

\begin_layout Standard
Using the algebraic properties we can construct some common collections.
 First, the specification 
\family typewriter
%CI
\family default
 denotes a set: a collection for which order and multiplicity are not significan
t.
 Sets within the set are preserved; if this is not desired, use 
\family typewriter
%ACI
\family default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> %CI(4,4,5,Red,"Joe",Blue,4,%CI(Red,Blue))
\end_layout

\begin_layout Plain Layout

$_repl5 = %CI(4, 5, Red:SYMBOL, "Joe", Blue:SYMBOL, %CI(Red:SYMBOL, Blue:SYMBOL)
)
\end_layout

\begin_layout Plain Layout

e> %ACI(4,4,5,Red,"Joe",Blue,4,%ACI(Red,Blue))
\end_layout

\begin_layout Plain Layout

$_repl6 = %ACI(4, 5, Red:SYMBOL, "Joe", Blue:SYMBOL)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If we omit idempotency or specify 
\emph on
not
\emph default
 idempotent with 
\family typewriter
!I
\family default
, then we have a multiset or bag, where multiple elements are preserved
 (though order still does no matter).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> %C(4,4,5,Red,"Joe",Blue,4,%CI(Red,Blue))
\end_layout

\begin_layout Plain Layout

$_repl7 = %C(4, 4, 5, Red:SYMBOL, "Joe", Blue:SYMBOL, 4, %CI(Red:SYMBOL,
 Blue:SYMBOL))
\end_layout

\begin_layout Plain Layout

e> %AC(4,4,5,Red,"Joe",Blue,4,%AC(Red,Blue))
\end_layout

\begin_layout Plain Layout

$_repl8 = %AC(4, 4, 5, Red:SYMBOL, "Joe", Blue:SYMBOL, 4, Red:SYMBOL, Blue:SYMBO
L)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Omitting commutativity or specifying 
\emph on
not
\emph default
 commutative with 
\family typewriter
!C
\family default
 results in a list.
 If we want lists to be flattened, we can specify associativity.
 Likewise, if we want only the first instance of an element, we can specify
 idempotency.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> %(4,4,5,Red,"Joe",Blue,4,%(Red,Blue))
\end_layout

\begin_layout Plain Layout

$_repl9 = %(4, 4, 5, Red:SYMBOL, "Joe", Blue:SYMBOL, 4, %(Red:SYMBOL, Blue:SYMBO
L))
\end_layout

\begin_layout Plain Layout

e> %A(4,4,5,Red,"Joe",Blue,4,%A(Red,Blue))
\end_layout

\begin_layout Plain Layout

$_repl10 = %A(4, 4, 5, Red:SYMBOL, "Joe", Blue:SYMBOL, 4, Red:SYMBOL, Blue:SYMBO
L)
\end_layout

\begin_layout Plain Layout

e> %AI(4,4,5,Red,"Joe",Blue,4,%AI(Red,Blue))
\end_layout

\begin_layout Plain Layout

$_repl11 = %AI(4, 5, Red:SYMBOL, "Joe", Blue:SYMBOL)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Properties Specifications as Operators
\end_layout

\begin_layout Standard
It was mentioned previously that the algebraic properties specification
 looks like an operator.
 In fact, it can function similarly to one, too.
 We use the applicative dot (
\family typewriter
.
\family default
) to apply it to another collection.
 Specified properties 
\emph on
override
\emph default
 the properties of the argument.
 For instance, if 
\family typewriter
%A
\family default
 is applied to 
\family typewriter
%C
\family default
, the result is 
\family typewriter
%AC
\family default
.
 Likewise, if 
\family typewriter
%A
\family default
 is applied to 
\family typewriter
%!AC
\family default
, the result is again 
\family typewriter
%AC
\family default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> %A.%C
\end_layout

\begin_layout Plain Layout

$_repl11 = %AC
\end_layout

\begin_layout Plain Layout

e> %A.%!AC
\end_layout

\begin_layout Plain Layout

$_repl12 = %AC
\end_layout

\begin_layout Plain Layout

e> %AD[0].%CD[2]
\end_layout

\begin_layout Plain Layout

$_repl13 = %ACD[0]
\end_layout

\begin_layout Plain Layout

e> (%A.%I).%(3,%AI(3),3)
\end_layout

\begin_layout Plain Layout

$_repl14 = %AI(3)
\end_layout

\begin_layout Plain Layout

e> %A.%I(3,%I(3),3)
\end_layout

\begin_layout Plain Layout

$_repl15 = %AI(3, %I(3))
\end_layout

\begin_layout Plain Layout

e> %A.%I(3,%AI(3),3)
\end_layout

\begin_layout Plain Layout

$_repl16 = %AI(3)
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Long-Property-Specifications"

\end_inset

Long Property Specifications
\end_layout

\begin_layout Standard
A properties specification like 
\family typewriter
%AC!ID[0]
\family default
 is terse almost to the point of being unreadable.
 If a properties specification contains no variables or other complex terms,
 it can be written in an alternate form, replacing the letters with the
 entire property name, and negation with 
\family typewriter
not
\family default
.
 The above specification can be written in the following form.
\end_layout

\begin_layout LyX-Code
% associative, commutative, not idempotent, identity 0
\end_layout

\begin_layout Standard
The commas are required, and spaces are allowed.
 This form is much more readable, but also much longer.
 Note that absorbers are specified via the 
\family typewriter
absorber
\family default
 keyword, followed by the absorber atom.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> %associative.%commutative
\end_layout

\begin_layout Plain Layout

$_repl1 = %AC
\end_layout

\begin_layout Plain Layout

e> %associative.% not associative, commutative
\end_layout

\begin_layout Plain Layout

$_repl2 = %AC
\end_layout

\begin_layout Plain Layout

e> (%associative, identity 0).%commutative, identity 2
\end_layout

\begin_layout Plain Layout

$_repl3 = %ACD[0]
\end_layout

\begin_layout Plain Layout

e> (%associative.%idempotent).%(3,%associative,idempotent(3),3)
\end_layout

\begin_layout Plain Layout

$_repl4 = %AI(3)
\end_layout

\begin_layout Plain Layout

e> %associative.%idempotent(3,%idempotent(3),3)
\end_layout

\begin_layout Plain Layout

$_repl5 = %AI(3, %I(3))
\end_layout

\begin_layout Plain Layout

e> %associative.%idempotent(3,%idempotent, associative(3),3)
\end_layout

\begin_layout Plain Layout

$_repl6 = %AI(3)
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Operators"

\end_inset

Operators
\end_layout

\begin_layout Standard
In general, operators denote mappings on atoms.
 However, Elision manipulates operators symbolically, so they should be
 regarded as mathematical functions or symbols, and not in the computer
 language sense.
 Elision supports the following kinds of operator.
\end_layout

\begin_layout Itemize
A 
\emph on
symbolic
\emph default
 operator is simply an atom that is manipulated by the system through rewriting.
 A Scala 
\emph on
closure
\emph default
 can be provided to construct instances of the operator, making the operator
 a 
\emph on
native
\emph default
 operator.
 This is how arithmetic operators, for example, are implemented.
\end_layout

\begin_layout Itemize
An 
\emph on
immediate
\emph default
 or 
\emph on
case
\emph default
 operator denotes a kind of macro.
 One or more patterns are provided, and arguments are matched against patterns,
 in order.
 The result of the match is used to construct a new atom, which is the 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 of the operator application.
 Case operators provide for a kind of controlled polymorphism, and can operate
 in ways that a symbolic operator cannot.
\end_layout

\begin_layout Standard
Operators must be defined in the current context to be used by name.
 This is done via the built-in 
\family typewriter
def
\family default
 operator.
 If you are trying to define an operator specified by a bound variable,
 you must use the built-in 
\family typewriter
eval
\family default
 operator to first replace the variable with its binding.
 Operator redefinition is permissible, but results in a warning.
 Finally, operators are a special form (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Special-Forms"

\end_inset

), so they may be specified in more than one way.
 In this chapter we present only one style of operator definition to simplify
 the discussion.
 Other forms are potentially more useful for matching and rewriting (see
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Matching-and-Rewriting"

\end_inset

).
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> {operator #name=foo #params=%($x)}
\end_layout

\begin_layout Plain Layout

$_repl35 = {: operator:SYMBOL { binds name -> foo:SYMBOL params -> %($x)
 } :}
\end_layout

\begin_layout Plain Layout

e> def($_repl35)
\end_layout

\begin_layout Plain Layout

ERROR: Atom is not a named operator: $_repl35
\end_layout

\begin_layout Plain Layout

e> def(eval($_repl35))
\end_layout

\begin_layout Plain Layout

Defined operator foo.
\end_layout

\begin_layout Plain Layout

e> def({operator #name=foo #params=%($x)})
\end_layout

\begin_layout Plain Layout

WARNING: Redefining operator foo.
\end_layout

\begin_layout Plain Layout

WARNING: Prior definition: {: operator:SYMBOL { binds name -> foo:SYMBOL
 params -> %($x)
\end_layout

\begin_layout Plain Layout

} :}
\end_layout

\begin_layout Plain Layout

Defined operator foo.
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Symbolic-Operators"

\end_inset

Symbolic Operators
\end_layout

\begin_layout Standard
A symbolic operator declaration must have the following elements.
\end_layout

\begin_layout Itemize
A 
\emph on
name
\emph default
, specified as a symbol.
 For example, 
\family typewriter
add
\family default
.
\end_layout

\begin_layout Itemize
A 
\emph on
type
\emph default
, which is the type of the fully-applied operator.
 For example, the type of the integer add operator is 
\family typewriter
INTEGER
\family default
.
\end_layout

\begin_layout Itemize
A 
\emph on
parameter list
\emph default
, which specifies both the parameter types and also the operator's algebraic
 properties.
\end_layout

\begin_layout Standard
To specify a symbolic operator, give these three items in the following
 form:
\end_layout

\begin_layout LyX-Code
{ operator #name=NAME #type=TYPE #params=PARAMS }
\end_layout

\begin_layout Standard
where 
\family typewriter
NAME
\family default
 is the operator name, 
\family typewriter
TYPE
\family default
 is the type of the fully-applied operator, and 
\family typewriter
PARAMS
\family default
 is the parameter collection.
 The algebraic properties of this collection are the algebraic properties
 of the operator.
 If the 
\family typewriter
#type
\family default
 is 
\emph on
not
\emph default
 declared, it is assumed to be 
\family typewriter
ANY
\family default
.
\end_layout

\begin_layout Standard
The following are some examples of common operators.
\end_layout

\begin_layout LyX-Code
{ operator #name=iadd #type=INTEGER
\end_layout

\begin_layout LyX-Code
  #params=%AC!ID[0]($x:INTEGER, $y:INTEGER) }
\end_layout

\begin_layout LyX-Code
{ operator #name=imul #type=INTEGER
\end_layout

\begin_layout LyX-Code
  #params=%AC!ID[1]B[0]($x:INTEGER, $y:INTEGER) }
\end_layout

\begin_layout LyX-Code
{ operator #name=and #type=BOOLEAN
\end_layout

\begin_layout LyX-Code
  #params=%ACID[true]B[false]($P:BOOLEAN, $Q:BOOLEAN) }
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
To create a definition of a symbolic operator, use
\end_layout

\begin_layout Itemize

\family typewriter
core.TypedSymbolicOperator(name, type, parameters, description, detail)
\end_layout

\begin_layout Plain Layout
where 
\family typewriter
name
\family default
 is the operator's name (a string), 
\family typewriter
type
\family default
 is the type of the fully-applied operator (an atom), 
\family typewriter
parameters
\family default
 specifies both the operator's properties and the parameters and their types
 (it is an atom sequence), 
\family typewriter
description
\family default
 is the short one-line description of the operator, and 
\family typewriter
detail
\family default
 is the longer description of the operator and its use.
 The last two (
\family typewriter
description
\family default
 and 
\family typewriter
detail
\family default
) are optional.
 The following code creates the two examples given previously (the 
\family typewriter
or
\family default
 and 
\family typewriter
add
\family default
 operators).
\end_layout

\begin_layout LyX-Code
import ornl.elision.core._
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
// Make the Boolean inclusive or operator.
\end_layout

\begin_layout LyX-Code
val orOp = TypedSymbolicOperator("or", BOOLEAN,
\end_layout

\begin_layout LyX-Code
  AtomSeq(Associative(true) and Commutative(true) and Idempotent(true)
\end_layout

\begin_layout LyX-Code
          and Absorber(true) and Identity(false),
\end_layout

\begin_layout LyX-Code
          Variable(BOOLEAN,"P"), Variable(BOOLEAN,"Q")),
\end_layout

\begin_layout LyX-Code
  "Compute the Boolean inclusive OR.",
\end_layout

\begin_layout LyX-Code
  """|This operator computes the Boolean inclusive OR of its arguments.
\end_layout

\begin_layout LyX-Code
     |All arguments must be Boolean values.""".stripMargin)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
// Make the integer add operator definition.
\end_layout

\begin_layout LyX-Code
val addOp = TypedSymbolicOperator("add", INTEGER,
\end_layout

\begin_layout LyX-Code
  AtomSeq(Associative(true) and Commutative(true) and Idempotent(false)
\end_layout

\begin_layout LyX-Code
          and Identity(0), Variable(INTEGER,"x"), Variable(INTEGER,"y")),
\end_layout

\begin_layout LyX-Code
  "Compute the integer sum of the arguments.",
\end_layout

\begin_layout LyX-Code
  """|Compute the integer sum of the arguments.""".stripMargin)
\end_layout

\begin_layout Plain Layout
Operator definitions should be installed in an instance of 
\family typewriter
core.OperatorLibrary
\family default
, typically found in an instance of 
\family typewriter
core.Context
\family default
.
 A context is automatically created and provided by the REPL, so if you
 are interacting with the REPL you do not need to worry about this.
 Contexts and operator libraries are explained in more detail in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Contexts"

\end_inset

.
 If you have a context instance, you can install a new operator by first
 getting the operator library from the context with 
\family typewriter
operatorLibrary
\family default
, and then invoking 
\family typewriter
add(opdef)
\family default
 on the instance, where 
\family typewriter
opdef
\family default
 is the operator definition.
\end_layout

\begin_layout Plain Layout
For instance, if 
\family typewriter
context
\family default
 is an instance of 
\family typewriter
core.Context
\family default
, then the operators defined above can be installed with the following lines
 of code.
\end_layout

\begin_layout LyX-Code
// Install definitions.
\end_layout

\begin_layout LyX-Code
context.operatorLibrary.add(orOp)
\end_layout

\begin_layout LyX-Code
context.operatorLibrary.add(addOp)
\end_layout

\begin_layout Plain Layout
The operator library is also where you register a closure for a symbolic
 operator.
 The closure must take a triple, consisting of the operator, the argument
 list as an instance of 
\family typewriter
core.AtomList
\family default
, and an instance of 
\family typewriter
core.Bindings
\family default
.
 The bindings are the result of matching the operator parameters against
 the arguments, and may be useful in some cases.
 The closure must then return an atom.
 Matching, binding, and rewriting are all explained in more detail in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Matching-and-Rewriting"

\end_inset

.
 You register the native handler using the 
\family typewriter
core.OperatorLibrary.register(name, handler)
\family default
 instance method, where 
\family typewriter
name
\family default
 is the (string) name of the operator, and 
\family typewriter
handler
\family default
 is the closure described above.
 The following registers a native constructor for 
\family typewriter
add
\family default
, but does use some methods not explained just yet.
\end_layout

\begin_layout LyX-Code
// Define add as a symbolic operator.
\end_layout

\begin_layout LyX-Code
context.operatorLibrary.register("add",
\end_layout

\begin_layout LyX-Code
  (op: Operator, args: AtomSeq, _) => {
\end_layout

\begin_layout LyX-Code
    // Accumulate the integer literals found.
\end_layout

\begin_layout LyX-Code
	var lits:BigInt = 0
\end_layout

\begin_layout LyX-Code
	// Accumulate other atoms found.
\end_layout

\begin_layout LyX-Code
	var other = IndexedSeq[BasicAtom]()
\end_layout

\begin_layout LyX-Code
	// Traverse the list and divide the atoms.
\end_layout

\begin_layout LyX-Code
	args.foreach {
\end_layout

\begin_layout LyX-Code
	  x => x match {
\end_layout

\begin_layout LyX-Code
	    case IntegerLiteral(_, value) => lits += value
\end_layout

\begin_layout LyX-Code
	    case _ => other :+= x
\end_layout

\begin_layout LyX-Code
	  }
\end_layout

\begin_layout LyX-Code
	}
\end_layout

\begin_layout LyX-Code
	// Now add the accumulated literals to the list.
\end_layout

\begin_layout LyX-Code
	other :+= Literal(INTEGER, lits)
\end_layout

\begin_layout LyX-Code
	// Construct and return a new operator application.
\end_layout

\begin_layout LyX-Code
	Apply(op, AtomSeq(NoProps, other), true)
\end_layout

\begin_layout LyX-Code
})
\end_layout

\begin_layout Plain Layout
It is the job of the 
\family typewriter
core.Apply
\family default
 class to create operator (and other) applications.
 While this is explained in more detail in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:The-Applicative-Dot"

\end_inset

, we note some important things here.
\end_layout

\begin_layout Plain Layout
First, 
\family typewriter
core.Apply
\family default
 understands how to use the operator to process absorbers and identities,
 etc., and this processing is performed 
\emph on
first
\emph default
.
 Thus it is possible to attempt to construct a symbolic operator application
 with a native constructor and never have the native constructor get invoked.
 For instance, 
\family typewriter
add(0)
\family default
 is immediately rewritten to 
\family typewriter
0
\family default
, and the native constructor is never invoked.
\end_layout

\begin_layout Plain Layout
Second, the native constructor may 
\emph on
re
\emph default
-invoke 
\family typewriter
core.Apply
\family default
, as is done in the handler for 
\family typewriter
add
\family default
 shown above.
 This can simplify the native constructor since it does not have to worry
 about identities, etc.
 In the 
\family typewriter
add
\family default
 constructor, the result for 
\family typewriter
lits
\family default
 might be zero.
 By re-invoking 
\family typewriter
core.Apply
\family default
 it will get correctly processed.
\end_layout

\begin_layout Plain Layout
This second case leads to a potential problem.
 The 
\family typewriter
core.Apply
\family default
 processing will invoke the native constructor, and our native constructor
 invokes 
\family typewriter
core.Apply
\family default
.
 To prevent this recursion we pass 
\family typewriter
true
\family default
 as the optional third argument to 
\family typewriter
core.Apply
\family default
 to prevent re-invoking the native constructor.
 It is thus possible to write a native constructor that does some processing,
 lets itself get re-invoked, does more processing, etc., until it finally
 terminates the cycle.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The properties specified for the operator are interpreted a bit differently
 from how they are interpreted for collections.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Operator-Properties"

\end_inset

 explains how they are interpreted.
\end_layout

\begin_layout Standard
Symbolic operators can be defined using a much more terse syntax.
 In this form the prototype is written directly, and the name, parameters,
 and type are pulled from it.
 For instance, the prototype 
\family typewriter
imul($x:INTEGER, $y:INTEGER):INTEGER
\family default
 specifies the name, parameters and their types, and the type of the fully-appli
ed operator.
 Note that it does 
\emph on
not
\emph default
 specify the properties of the operator.
 Those are optionally specified by following the prototype with 
\family typewriter
is
\family default
 and then the algebraic properties specification.
 Use 
\family typewriter
{!
\family default
...
\family typewriter
}
\family default
 to enclose the entire operator definition.
 The three operators given previously can be written as follows using this
 new syntax.
\end_layout

\begin_layout LyX-Code
{! iadd($x:INTEGER, $y:INTEGER):INTEGER is %AC!ID[0] }
\end_layout

\begin_layout LyX-Code
{! imul($x:INTEGER, $y:INTEGER):INTEGER is %AC!ID[1]B[0] }
\end_layout

\begin_layout LyX-Code
{! and($P:BOOLEAN, $Q:BOOLEAN):BOOLEAN is %ACID[true]B[false] }
\end_layout

\begin_layout Standard
If you use long property specifications (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Long-Property-Specifications"

\end_inset

) then you can drop the leading 
\family typewriter
%
\family default
.
\end_layout

\begin_layout LyX-Code
{! iadd($x:INTEGER, $y:INTEGER):INTEGER is
\end_layout

\begin_layout LyX-Code
   associative, commutative, not idempotent, identity 0}
\end_layout

\begin_layout LyX-Code
{! imul($x:INTEGER, $y:INTEGER):INTEGER is
\end_layout

\begin_layout LyX-Code
   associative, commutative, not idempotent,
\end_layout

\begin_layout LyX-Code
   identity 1, absorber 0}
\end_layout

\begin_layout LyX-Code
{! and($P:BOOLEAN, $Q:BOOLEAN):BOOLEAN is
\end_layout

\begin_layout LyX-Code
   associative, commutative, idempotent,
\end_layout

\begin_layout LyX-Code
   identity true, absorber false}
\end_layout

\begin_layout Standard
This is much more readable, but also much longer.
\end_layout

\begin_layout Standard
After specifying the prototype the description and details may be specified
 as usual.
 In fact, the type can be specified in the usual manner (with 
\family typewriter
#type
\family default
), if desired.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Operator-Properties"

\end_inset

Operator Properties
\end_layout

\begin_layout Standard
As with collections, operators have associated algebraic properties; in
 fact, they are the same as those for sequences, and are specified in the
 same manner.
 For example, addition is associative, commutative, not idempotent, and
 has an identity of zero: 
\family typewriter
%AC!ID[0]
\family default
.
 Multiplication is associative, commutative, not idempotent, has an identity
 of one, and an absorber of zero: 
\family typewriter
%d[1]b[0]!ica
\family default
.
 Boolean logical or is associative, commutative, idempotent, has an identity
 of false and an absorber of true: 
\family typewriter
%ACID[false]B[true]
\family default
.
\end_layout

\begin_layout Standard
Each property is described in more detail in the following subsections as
 it applies to operators.
 There are restrictions on the properties of operators that are not present
 for collections (specifically, associativity is required in many cases),
 and these are discussed in the following subsections.
\end_layout

\begin_layout Subsection
Associativity
\end_layout

\begin_layout Standard
An associative operator 
\begin_inset Formula $f$
\end_inset

 can have its arguments grouped arbitrarily.
 Thus 
\begin_inset Formula $f(a,b,c)=f(f(a,b),c)=f(a,f(b,c))$
\end_inset

.
 Note that any argument could be replaced with another application, so any
 number of arguments is possible.
\end_layout

\begin_layout Standard
Suppose we define operator 
\begin_inset Formula $f$
\end_inset

 to have prototype 
\begin_inset Formula $f(a:A,b:B):F$
\end_inset

.
 Since we can replace either 
\begin_inset Formula $a$
\end_inset

 or 
\begin_inset Formula $b$
\end_inset

 with another application of 
\begin_inset Formula $f$
\end_inset

, we conclude that 
\begin_inset Formula $F\subseteq A$
\end_inset

 and 
\begin_inset Formula $F\subseteq B$
\end_inset

.
 We further note the following, by associativity.
\begin_inset Formula 
\[
f(f(c:A,d:B),b:B)=f(c:A,f(d:B,b:B))
\]

\end_inset

Thus it must be the case that 
\begin_inset Formula $B\subseteq A$
\end_inset

.
 By a similar argument we conclude that 
\begin_inset Formula $A\subseteq B$
\end_inset

, and thus 
\begin_inset Formula $A=B$
\end_inset

.
 For these reasons we require that all parameters of an associative operator
 have the same type, and that the parameter type must be the same as the
 overall operator type.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> { operator #name=bad1 #type=INTEGER
\end_layout

\begin_layout Plain Layout

 >   #params=%A($x: INTEGER, $y: STRING) }
\end_layout

\begin_layout Plain Layout

ERROR: The operator bad1 is marked as associative, but all parameters
\end_layout

\begin_layout Plain Layout

do not hae the same type, as required: %A($x:INTEGER, $y:STRING)
\end_layout

\begin_layout Plain Layout

e> { operator #name=bad2 #type=STRING
\end_layout

\begin_layout Plain Layout

 >   #params=%A($x: INTEGER, $y: INTEGER) }
\end_layout

\begin_layout Plain Layout

ERROR: The operator bad2 is marked as associative, but the parameter
\end_layout

\begin_layout Plain Layout

type (INTEGER) is not the same as the fully-applied type (STRING).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An associative operator must declare 
\emph on
exactly
\emph default
 two parameters.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> { operator #name=bad3 #type=INTEGER
\end_layout

\begin_layout Plain Layout

 >   #params=%A($x: INTEGER) }
\end_layout

\begin_layout Plain Layout

ERROR: The operator bad3 is marked as associative, but does not have
\end_layout

\begin_layout Plain Layout

exactly two parameters, as required: %A($x:INTEGER)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Associativity is 
\emph on
required
\emph default
 by idempotency, any identity, and any absorber.
\end_layout

\begin_layout Subsection
Commutativity
\end_layout

\begin_layout Standard
A commutative (or abelian) operator 
\begin_inset Formula $f$
\end_inset

 can have its arguments re-ordered arbitrarily.
 Thus 
\begin_inset Formula $f(a,b)=f(b,a)$
\end_inset

.
 If we provide type information, we see the following: 
\begin_inset Formula $f(a:A,b:B)=f(b:B,a:A)$
\end_inset

, and we conclude that 
\begin_inset Formula $A\subseteq B$
\end_inset

 and 
\begin_inset Formula $B\subseteq A$
\end_inset

, or 
\begin_inset Formula $A=B$
\end_inset

.
 We thus require that all arguments to a commutative operator have the same
 type, though this need not be the type of the fully-applied operator.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> { operator #name=bad #type=STRING
\end_layout

\begin_layout Plain Layout

 >   #params=%C($x: INTEGER, $y: STRING) }
\end_layout

\begin_layout Plain Layout

ERROR: The operator bad is marked as commutative, but all parameters
\end_layout

\begin_layout Plain Layout

do not hae the same type, as required: %C($x:INTEGER, $y:STRING)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A commutative operator must declare 
\emph on
at least
\emph default
 two parameters.
\end_layout

\begin_layout Subsection
Idempotency
\end_layout

\begin_layout Standard
An idempotent operator 
\begin_inset Formula $f$
\end_inset

 has the property that 
\begin_inset Formula $f(a,a)=f(a)$
\end_inset

, so repeated arguments are discarded.
 Because the length of the argument list can change, idempotent operators
 are required to be associative.
 An example of an idempotent operator is the Boolean inclusive 
\emph on
or
\emph default
, since 
\begin_inset Formula $\mbox{or}(x,y,x)=\mbox{or}(x,y)$
\end_inset

.
 Idempotency imposes no additional restrictions on an operator beyond those
 imposed by associativity, which is required.
\end_layout

\begin_layout Standard
As an example, we implement multisets and sets using symbolic operators.
 A 
\emph on
multiset
\emph default
 allows repeated elements to be present.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> def({ operator #name=mset #params=%AC($x,$y) })
\end_layout

\begin_layout Plain Layout

e> mset(7, fred, "James", blue, 7, blue)
\end_layout

\begin_layout Plain Layout

$_repl18 = mset(7, fred:SYMBOL, "James", blue:SYMBOL, 7, blue:SYMBOL)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A 
\emph on
set
\emph default
 does not allow repeated elements.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> def({ operator #name=set #params=%ACI($x,$y) })
\end_layout

\begin_layout Plain Layout

e> set(7, fred, "James", blue, 7, blue)
\end_layout

\begin_layout Plain Layout

$_repl19 = set(7, fred:SYMBOL, "James", blue:SYMBOL)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Including idempotency in the list of properties allows a simple implementation
 of sets.
 Examples of idempotent operators are the logical 
\emph on
or
\emph default
 and 
\emph on
and
\emph default
.
\end_layout

\begin_layout Subsection
Identity
\end_layout

\begin_layout Standard
An operator 
\begin_inset Formula $f$
\end_inset

 can have an associated named identity element 
\begin_inset Formula $e$
\end_inset

, with the property that 
\begin_inset Formula $f(x,e)=f(e,x)=f(x)=x$
\end_inset

.
 Instances of a named identity are discarded from the argument list.
 Because the length of the argument list can change, only associative operators
 can have a named identity.
\end_layout

\begin_layout Standard
Named identity elements include 
\emph on
zero
\emph default
 for addition, 
\emph on
one
\emph default
 for multiplication, 
\emph on
false
\emph default
 for Boolean inclusive 
\emph on
or
\emph default
, and 
\emph on
true
\emph default
 for Boolean 
\emph on
and
\emph default
.
\end_layout

\begin_layout Standard
Further, 
\begin_inset Formula $f()$
\end_inset

 is regarded as an alternate name for a named identity 
\begin_inset Formula $e$
\end_inset

.
 The type of the identity must match the parameter type.
\end_layout

\begin_layout Subsection
Absorber
\end_layout

\begin_layout Standard
An operator 
\begin_inset Formula $f$
\end_inset

 can have an associated absorber element 
\begin_inset Formula $z$
\end_inset

, with the property that 
\begin_inset Formula $f(x,z)=f(z,x)=z$
\end_inset

.
 If an absorber is present in the argument list then the entire operator
 application is reduced to the absorber.
 Elision currently requires that operators with absorbers be associative,
 though this is not essential for any mathematical reason.
\end_layout

\begin_layout Standard
Absorber elements include zero for multiplication, true for Boolean inclusive
 or, and false for Boolean and.
 The type of the absorber must match the parameter type.
\end_layout

\begin_layout Subsection
Construction
\end_layout

\begin_layout Standard
Atoms are transformed when entered, based on their properties, before any
 other processing, including a native handler, is performed.
 Suppose we have the following definitions.
\end_layout

\begin_layout LyX-Code
{operator #name=foo #params=%AD[0]($x:INTEGER,$y:INTEGER) #type=INTEGER}
\end_layout

\begin_layout LyX-Code
{operator #name=bar #params=%AB[true]($x:BOOLEAN,$y:BOOLEAN) #type=BOOLEAN}
\end_layout

\begin_layout Itemize

\family typewriter
foo($x:INTEGER, foo($y:INTEGER, $z:INTEGER))
\family default
 becomes 
\family typewriter
foo($x:INTEGER, $y:INTEGER, $z:INTEGER)
\family default
 because associative applications are 
\begin_inset Quotes eld
\end_inset

flattened.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
foo(5,0,2)
\family default
 becomes 
\family typewriter
foo(5,2)
\family default
 because identities are discarded.
\end_layout

\begin_layout Itemize

\family typewriter
bar(true,false, $x:BOOLEAN)
\family default
 becomes 
\family typewriter
true
\family default
 because 
\family typewriter
true
\family default
 is an absorber.
\end_layout

\begin_layout Itemize

\family typewriter
foo(0,0,0)
\family default
 becomes 
\family typewriter
0
\family default
 because discarding identities leaves 
\family typewriter
foo()
\family default
, which is equal to the identity 
\family typewriter
0
\family default
.
\end_layout

\begin_layout Standard
Once this processing is complete, the system applies any native handler.
\end_layout

\begin_layout Section
Operator Applications
\end_layout

\begin_layout Standard
Once an operator is defined, it can be applied to arguments.
 If the arguments match the parameters then the operator is fully applied
 and a new atom is created called an 
\emph on
apply
\emph default
.
 Assuming the 
\family typewriter
and
\family default
, 
\family typewriter
or
\family default
, and 
\family typewriter
typeof
\family default
 operators given in the previous section are defined, the following are
 all valid applications.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="4">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
add(4,5,$x)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
or($x,false)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
typeof(6)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
typeof(add($x,9))
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Because of the properties of the 
\family typewriter
or
\family default
 operator, the second term 
\family typewriter
or($x,false)
\family default
 immediately reduces to 
\family typewriter
$x
\family default
.
 The last two reduce immediately to 
\family typewriter
INTEGER
\family default
.
\end_layout

\begin_layout Standard
Operator applications can be nested, provided types match.
 The following is an example.
\end_layout

\begin_layout LyX-Code
or(equal(add($x,21),64),equal(add($y,17),32))
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Operator application is explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:The-Applicative-Dot"

\end_inset

.
\end_layout

\begin_layout Plain Layout
Before an operator can be applied, you must get an instance of that operator.
 If you have installed the operator definition in an operator library, you
 can retrieve it via either the 
\family typewriter
get(name)
\family default
 instance method of 
\family typewriter
core.OperatorLibrary
\family default
, or via the 
\family typewriter
apply(name)
\family default
 instance method, where 
\family typewriter
name
\family default
 is the operator name.
 The 
\family typewriter
get(name)
\family default
 method returns an optional 
\family typewriter
core.OperatorRef
\family default
, returning 
\family typewriter
None
\family default
 if the operator is not known.
 The 
\family typewriter
apply(name)
\family default
 method will will return an instance of 
\family typewriter
core.OperatorRef
\family default
, or throw an exception if the operator is not known.
\end_layout

\begin_layout Plain Layout
The operator itself can be obtained from the 
\family typewriter
core.OperatorRef
\family default
 instance via its 
\family typewriter
operator
\family default
 field.
 The following are two ways to obtain the 
\family typewriter
add
\family default
 operator, given a context instance 
\family typewriter
context
\family default
.
\end_layout

\begin_layout LyX-Code
context.operatorLibrary.get("add") match {
\end_layout

\begin_layout LyX-Code
  case Some(opref) => // Do something with the operator opref.operator
\end_layout

\begin_layout LyX-Code
  case None => // The operator is not known!
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
// The following throws an UndefinedOperatorException if
\end_layout

\begin_layout LyX-Code
// add is not known.
\end_layout

\begin_layout LyX-Code
context.operatorLibrary("add").operator
\end_layout

\begin_layout Plain Layout
Of course, you probably don't need (or even want) the actual operator; a
 reference to the operator is sufficient.
\end_layout

\begin_layout Plain Layout
Once you have the operator reference, you can apply it to arguments by just
 listing the arguments in parentheses after the reference, thus implicitly
 invoking the operator's (or reference's) 
\family typewriter
apply
\family default
 method.
 You can also use the 
\family typewriter
core.Apply
\family default
 class as explained in the next section.
 The following adds some numbers.
\end_layout

\begin_layout LyX-Code
context.operatorLibrary("add")(2,2,9)
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:The-Applicative-Dot"

\end_inset

The Applicative Dot
\end_layout

\begin_layout Standard
Operator applications can be written in two forms: 
\family typewriter
add(4,5,$x)
\family default
 and 
\family typewriter
add.%(4,5,$x)
\family default
.
 This second form uses the 
\emph on
applicative dot
\emph default
 and a collection to apply an operator to arguments.
 The two forms are equivalent; they are alternative ways to represent the
 same atom.
 The first form is actually a shorthand notation for the second.
 Both operators and atom lists are themselves atoms, and can be manipulated
 by the system.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Matching-and-Rewriting"

\end_inset

 the applicative dot notation will turn out to be very useful.
\end_layout

\begin_layout Standard
While operators are atoms, if you just evaluate 
\family typewriter
add
\family default
 by itself Elision will usually interpret this as a symbol of type 
\family typewriter
SYMBOL
\family default
.
 To force Elision to look this operator up, write 
\family typewriter
add:OPREF
\family default
.
 The 
\family typewriter
OPREF
\family default
 is not actually the type of the operator, but just a hint to force the
 Elision parser to look up the operator in the parser's context.
 If the operator is not known, an error is reported.
 The built in operator 
\family typewriter
getop
\family default
 can be used to get the actual operator from an operator reference.
\end_layout

\begin_layout Standard
The type of an operator
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
There are two exceptions.
 The operators 
\family typewriter
MAP
\family default
 and 
\family typewriter
xx
\family default
 are used to represent the type of operators, so they get special treatment.
 Their type is 
\family typewriter
ANY
\family default
.
\end_layout

\end_inset

 is a 
\emph on
mapping
\emph default
 from some domain to some range, deduced from the operator prototype.
 This can be obtained using the lambda trick presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Lambdas"

\end_inset

.
 With 
\family typewriter
add
\family default
 defined in the current REPL session, try the following.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> 
\backslash
$x:$T.$T.getop(add:OPREF)
\end_layout

\begin_layout Plain Layout

repl0 = MAP(xx(INTEGER, INTEGER), INTEGER)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The type for the 
\family typewriter
add
\family default
 operator is a mapping from pairs of integers to integers.
 The above expression parses correctly because the applicative dot binds
 the most weakly of all connectors; more weakly than the lambda dot, for
 instance, which binds more weakly than the type colon.
 Thus the expression is equal to the following.
\end_layout

\begin_layout LyX-Code
(
\backslash
$x:$T.$T).(getop(add:OPREF))
\end_layout

\begin_layout Standard
The applicative dot can be used to 
\begin_inset Quotes eld
\end_inset

glue
\begin_inset Quotes erd
\end_inset

 any two atoms together.
 The atom to the left of the dot is the 
\emph on
left-hand side (lhs)
\emph default
, while the atom to the right of the dot is the 
\emph on
right-hand side (rhs)
\emph default
.
 For instance the following are perfectly legal applications, though it
 is not entirely clear what the first and last examples 
\begin_inset Quotes eld
\end_inset

mean.
\begin_inset Quotes erd
\end_inset

 The parentheses are used in the first example to prevent 
\family typewriter
7.

\family default
 from being interpreted as a floating point number; a space between the
 
\family typewriter
7
\family default
 and the dot would also work.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="4">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
(7).$x
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
(
\backslash
$x:$T.$T).getop(add:OPREF)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
add.%(5,6)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
$x.$y
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Special-Forms"

\end_inset

 will introduce several other uses of the applicative dot.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
To create an apply using the applicative dot, use the 
\family typewriter
core.Apply(lhs,rhs)
\family default
 constructor, where 
\family typewriter
lhs
\family default
 is the left-hand side, and 
\family typewriter
rhs
\family default
 is the right-hand side.
 Here are the Scala code equivalents for the apply examples given previously.
\end_layout

\begin_layout LyX-Code
// (7).$x
\end_layout

\begin_layout LyX-Code
Apply(7,'x)
\end_layout

\begin_layout LyX-Code

\family typewriter
// (
\backslash
$x:$T.$T).getop(add:OPREF)
\end_layout

\begin_layout LyX-Code
Apply(Lambda(Variable('T,"x"),'T),
\end_layout

\begin_layout LyX-Code
  context.operatorLibrary("getop")(Literal(OPREF,'add)))
\end_layout

\begin_layout LyX-Code
// add.%(5,6)
\end_layout

\begin_layout LyX-Code
Apply(context.operatorLibrary("add"), AtomSeq(NoProps, 5, 6))
\end_layout

\begin_layout LyX-Code
// $x.$y
\end_layout

\begin_layout LyX-Code
Apply('x,'y)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Operators, Symbols, and Naked Symbols
\end_layout

\begin_layout Standard
If you type a symbol at the REPL prompt without type, this is regarded as
 a 
\begin_inset Quotes eld
\end_inset

naked
\begin_inset Quotes erd
\end_inset

 symbol, and is subject to special treatment.
 If the naked symbol appears on the left-hand side of an apply, the system
 will attempt to interpret it as an operator reference, and will look it
 up in the context.
 If it is not found, it will issue an error.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> fred
\end_layout

\begin_layout Plain Layout

$_repl14 = fred:SYMBOL
\end_layout

\begin_layout Plain Layout

e> fred(5)
\end_layout

\begin_layout Plain Layout

ERROR: The operator fred is not known.
\end_layout

\begin_layout Plain Layout

e> fred.james
\end_layout

\begin_layout Plain Layout

ERROR: The operator fred is not known.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To overcome this explicitly give the type of the symbol.
 Any type will suppress this behavior, but the most common (and obvious)
 type is 
\family typewriter
SYMBOL
\family default
.
 Enclosing the symbol in parentheses only helps with the simple operator
 application, but not with the applicative dot.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> fred:SYMBOL.james
\end_layout

\begin_layout Plain Layout

$_repl15 = (fred:SYMBOL.james:SYMBOL)
\end_layout

\begin_layout Plain Layout

e> (fred)(5)
\end_layout

\begin_layout Plain Layout

$_repl16 = fred:SYMBOL
\end_layout

\begin_layout Plain Layout

$_repl17 = 5
\end_layout

\begin_layout Plain Layout

e> (fred).5
\end_layout

\begin_layout Plain Layout

ERROR: The operator fred is not known.
\end_layout

\begin_layout Plain Layout

e> (fred:SYMBOL).5
\end_layout

\begin_layout Plain Layout

$_repl18 = (fred:SYMBOL.5)
\end_layout

\begin_layout Plain Layout

e> fred:SYMBOL(5)
\end_layout

\begin_layout Plain Layout

ERROR: The operator SYMBOL is not known.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The last line above is included just to emphasize that types are themselves
 atoms, and are subject to the same parsing rules.
\end_layout

\begin_layout Standard
The opposite of this is to explicitly state that a symbol is an operator
 reference, using 
\family typewriter
OPREF
\family default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> (fred:OPREF)(5)
\end_layout

\begin_layout Plain Layout

ERROR: The operator fred is not known.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You may be wondering why Elision doesn't simply treat a naked symbol as
 a simple symbol when there is no operator with that name, so 
\family typewriter
fred.5
\family default
 would be accepted.
 The reason is that if an operator with name 
\family typewriter
fred
\family default
 were later defined then the interpretation would be fundamentally changed
 (from a symbol to an operator), and the Elision design seeks to avoid that.
 This could 
\begin_inset Quotes eld
\end_inset

break
\begin_inset Quotes erd
\end_inset

 existing files of definitions and terms.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
The special type 
\family typewriter
OPREF
\family default
 is one place where the Scala API and REPL deviate.
 Consider the following code.
\end_layout

\begin_layout LyX-Code
Apply(Literal(OPREF, 'fred), Literal(5)).toParseString
\end_layout

\begin_layout Plain Layout
This yields the output 
\begin_inset Quotes eld
\end_inset


\family typewriter
(fred:OPREF.5)
\family default
,
\begin_inset Quotes erd
\end_inset

 but this fails the 
\begin_inset Quotes eld
\end_inset

round trip
\begin_inset Quotes erd
\end_inset

 test; parsing this string results in an attempt to look up the 
\family typewriter
fred
\family default
 operator in the current context.
\end_layout

\begin_layout Plain Layout
This difficulty arises from the fact that there is no 
\begin_inset Quotes eld
\end_inset

universal
\begin_inset Quotes erd
\end_inset

 context.
 The REPL and the parser have a context where they can look up 
\family typewriter
fred
\family default
, but the overall API does not.
\end_layout

\begin_layout Plain Layout
To prevent this future versions of Elision may do away with 
\family typewriter
OPREF
\family default
 at the API level, and more rigorously dispose of it during parsing, but
 for now remember that 
\family typewriter
OPREF
\family default
 is a piece of parser 
\begin_inset Quotes eld
\end_inset

magic.
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Case Operators
\end_layout

\begin_layout Standard
A case operator declaration must have the following elements.
\end_layout

\begin_layout Itemize
A 
\emph on
name
\emph default
, specified as a symbol.
 For example, 
\family typewriter
sum
\family default
.
\end_layout

\begin_layout Itemize
An optional 
\emph on
type
\emph default
, which is the type of the fully-applied operator.
 If not specified, 
\family typewriter
ANY
\family default
 is used.
\end_layout

\begin_layout Itemize
A 
\emph on
case list
\emph default
, which specifies the alternatives for the operator.
\end_layout

\begin_layout Standard
To specify a case operator, give these three items in the following form:
\end_layout

\begin_layout LyX-Code
{ operator #name=NAME #type=TYPE #cases CASES }
\end_layout

\begin_layout Standard
where 
\family typewriter
NAME
\family default
 is the operator name, 
\family typewriter
TYPE
\family default
 is the type of the fully-applied operator, and 
\family typewriter
CASES
\family default
 is the comma-separated list of alternatives.
 Again, if the 
\family typewriter
#type
\family default
 is 
\emph on
not
\emph default
 declared, it is assumed to be 
\family typewriter
ANY
\family default
.
\end_layout

\begin_layout Standard
A case definition defines an operator by explicitly giving the interpretation
 of the operator in terms of its argument.
 When the operator symbol appears on the left of an applicative dot (even
 when implicit) then each of the alternatives is considered, in order.
\end_layout

\begin_layout Standard
The alternatives can be any atom, but some atoms are special.
\end_layout

\begin_layout Itemize
If the atom is a 
\emph on
rewriter
\emph default
 (the 
\begin_inset Quotes eld
\end_inset

map pair
\begin_inset Quotes erd
\end_inset

 is the most common), then the rewrite is attempted.
 If it succeeds, then the result is the value of the operator application.
 If it fails, then the next alternative is tried.
\end_layout

\begin_layout Itemize
If the atom is an 
\emph on
applicable
\emph default
 (operators are the most common, but also algebraic property specifications),
 then the applicable is placed on the left hand side of the applicative
 dot, and the arguments on the right hand side.
 The result is the value of the operator and no further alternatives are
 considered.
\end_layout

\begin_layout Itemize
Otherwise the atom is the value of the operator.
\end_layout

\begin_layout Standard
The second and third cases are very simple, so we consider them first.
 The following creates an alias for the 
\family typewriter
add
\family default
 operator.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> def({operator #name=`+` #cases add:OPREF})
\end_layout

\begin_layout Plain Layout

Defined operator `+`.
\end_layout

\begin_layout Plain Layout

e> `+`(5,4,3)
\end_layout

\begin_layout Plain Layout

$_repl20 = 12
\end_layout

\end_inset

The following creates a constant function that yields the value one no matter
 what the arguments.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> def({operator #name=one #cases 1})
\end_layout

\begin_layout Plain Layout

Defined operator one.
\end_layout

\begin_layout Plain Layout

e> one(4,5)
\end_layout

\begin_layout Plain Layout

$_repl0 = 1 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first case uses a rewritable, which will be more fully explained in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Matching-and-Rewriting"

\end_inset

.
 Here we consider a simple one: the 
\emph on
map pair
\emph default
.
 A map pair consists of a pattern against which the argument list is matched,
 a text arrow (
\family typewriter
->
\family default
), and an atom specifying the value of the operator when the pattern matches
 the argument list.
\end_layout

\begin_layout Standard
The following is a general definition using cases.
\end_layout

\begin_layout LyX-Code
{operator #name=sum #cases
\end_layout

\begin_layout LyX-Code
          %($x: INTEGER) -> $x,
\end_layout

\begin_layout LyX-Code
          %($x: STRING) -> $x,
\end_layout

\begin_layout LyX-Code
          %AC($x: INTEGER, $y: INTEGER) -> add($x,$y),
\end_layout

\begin_layout LyX-Code
          %A($x: STRING, $y: STRING) -> ($x.$y)}
\end_layout

\begin_layout Standard
This definition allows adding both integers (via 
\family typewriter
add
\family default
) and strings (via the applicative dot).
 Note that the lists can specify properties to facilitate proper matching.
 Note also that 
\family typewriter
sum(5,"Fred")
\family default
 results in an error, as this does not match any case.
 Likewise, 
\family typewriter
sum()
\family default
 does not match any case, either.
 Suppose we want to allow the no-argument case but to leave it as 
\family typewriter
sum()
\family default
.
 We add an alternative with the form 
\family typewriter
%() -> _
\family default
.
 This matches the empty argument list.
 The value in this case is the underscore, which is a synonym for 
\family typewriter
ANY
\family default
, and is interpreted here to mean that the argument list should be left
 as it was at the start, yielding 
\family typewriter
sum()
\family default
 as the final answer.
\end_layout

\begin_layout Standard
Suppose we never want an undefined case; when we do not match a given case,
 we want to accept and leave the operator application unchanged, perhaps
 for symbolic manipulation.
 We can use 
\family typewriter
ANY
\family default
 as the pattern to catch this case.
 Consider the following alternate definition of 
\family typewriter
add
\family default
.
\end_layout

\begin_layout LyX-Code
{operator #name=sum #cases
\end_layout

\begin_layout LyX-Code
          %($x: INTEGER) -> $x,
\end_layout

\begin_layout LyX-Code
          %($x: STRING) -> $x,
\end_layout

\begin_layout LyX-Code
          %AC($x: INTEGER, $y: INTEGER) -> add($x,$y),
\end_layout

\begin_layout LyX-Code
          %A($x: STRING, $y: STRING) -> ($x.$y),
\end_layout

\begin_layout LyX-Code
          _ -> _}
\end_layout

\begin_layout Standard
In the last line the lone underscore (a synonym for 
\family typewriter
ANY
\family default
) matches anything.
 Thus 
\family typewriter
sum(5,"Fred")
\family default
 falls to this case and the result is 
\family typewriter
sum:OPTYPE.%(5,"Fred")
\family default
, or just 
\family typewriter
sum(5,"Fred")
\family default
, where construction halts.
 Note that we cannot directly refer to 
\family typewriter
sum
\family default
 inside the definition since the operator is not yet defined.
\end_layout

\begin_layout Standard
This generality allows some rather unorthodox things to occur.
 Consider the following.
\end_layout

\begin_layout LyX-Code
{operator #name=typeof #cases $x:$T -> $T}
\end_layout

\begin_layout Standard
Now we have an operator that generates the type of anything on the right
 of an applicative dot.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is not perfect! The lambda trick described elsewhere is the best way
 to obtain the type of an atom.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> typeof.5
\end_layout

\begin_layout Plain Layout

$_repl4 = INTEGER
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Because case operators explicitly allow polymorphism their type cannot be
 correctly inferred as simply as it was for symbolic operators.
 You have two options.
 You can figure out the correct type yourself and include it with 
\family typewriter
#type=
\family default
, or you can omit it and Elision will assign the operator the type 
\family typewriter
ANY
\family default
.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
To create a definition of a case operator, use
\end_layout

\begin_layout Itemize

\family typewriter
core.CaseOperator(name, type, cases, description, detail)
\end_layout

\begin_layout Plain Layout
where 
\family typewriter
name
\family default
 is the operator's name (a string), 
\family typewriter
type
\family default
 is the type of the fully-applied operator (an atom), 
\family typewriter
cases
\family default
 specifies the alternatives (it is an atom sequence), 
\family typewriter
description
\family default
 is the short one-line description of the operator, and 
\family typewriter
detail
\family default
 is the longer description of the operator and its use.
 The last two (
\family typewriter
description
\family default
 and 
\family typewriter
detail
\family default
) are optional.
 The following code creates the examples given previously (the 
\family typewriter
sum
\family default
 operator).
\end_layout

\begin_layout LyX-Code
import ornl.elision.core._
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
// Make the generic sum operator.
\end_layout

\begin_layout LyX-Code
val List(x,y) = List("x","y").map(Variable(INTEGER,_))
\end_layout

\begin_layout LyX-Code
val List(s,t) = List("s","t").map(Variable(STRING,_))
\end_layout

\begin_layout LyX-Code
val add = context.operatorLibrary("add")
\end_layout

\begin_layout LyX-Code
val sumOp = CaseOperator("sum", ANY,
\end_layout

\begin_layout LyX-Code
  AtomSeq(NoProps,
\end_layout

\begin_layout LyX-Code
    MapPair(AtomSeq(NoProps,x), x),
\end_layout

\begin_layout LyX-Code
    MapPair(AtomSeq(NoProps,s), s),
\end_layout

\begin_layout LyX-Code
    MapPair(AtomSeq(Associative(true) and Commutative(true), x, y),
\end_layout

\begin_layout LyX-Code
      add(x,y)),
\end_layout

\begin_layout LyX-Code
    MapPair(AtomSeq(Associative(true), s, t), Apply(s, t)),
\end_layout

\begin_layout LyX-Code
    MapPair(ANY, ANY)),
\end_layout

\begin_layout LyX-Code
  "Compute the generic polymorphic sum.",
\end_layout

\begin_layout LyX-Code
  "This operator computes the polymorphic sum of its arguments.")
\end_layout

\begin_layout Plain Layout
The last two strings provide documentation, as described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Documenting-Operators"

\end_inset

.
 As with symbolic operators, the operator definition should be installed
 in an instance of 
\family typewriter
core.OperatorLibrary
\family default
, typically found in an instance of 
\family typewriter
core.Context
\family default
.
\end_layout

\begin_layout Plain Layout
Unlike symbolic operators, case operators should not be given native handlers.
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Documenting-Operators"

\end_inset

Documenting Operators
\end_layout

\begin_layout Standard
Operators may include two additional elements.
 A short one-line description of the operator can be given via 
\family typewriter
#description
\family default
, while a longer description of the operator can be given via 
\family typewriter
#detail
\family default
.
 If these are included, they will be used by Elision's help system.
 The general style is to describe the operator in abstract terms in its
 
\family typewriter
#description
\family default
 and not mention parameters by name.
 Then in the 
\family typewriter
#detail
\family default
 the parameters may be mentioned directly.
\end_layout

\begin_layout LyX-Code
{operator #name=sum #cases
\end_layout

\begin_layout LyX-Code
          %($x: INTEGER) -> $x,
\end_layout

\begin_layout LyX-Code
          %($x: STRING) -> $x,
\end_layout

\begin_layout LyX-Code
          %AC($x: INTEGER, $y: INTEGER) -> add($x,$y),
\end_layout

\begin_layout LyX-Code
          %A($x: STRING, $y: STRING) -> ($x.$y),
\end_layout

\begin_layout LyX-Code
          _ -> _
\end_layout

\begin_layout LyX-Code
#description="Compute the generic polymorphic sum."
\end_layout

\begin_layout LyX-Code
#detail="This operator computes the polymorphic sum of its arguments."
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> def({operator #name=sum #cases
\end_layout

\begin_layout Plain Layout

 >           %($x: INTEGER) -> $x,
\end_layout

\begin_layout Plain Layout

 >           %($x: STRING) -> $x,
\end_layout

\begin_layout Plain Layout

 >           %AC($x: INTEGER, $y: INTEGER) -> add($x,$y),
\end_layout

\begin_layout Plain Layout

 >           %A($x: STRING, $y: STRING) -> ($x.$y),
\end_layout

\begin_layout Plain Layout

 >           _ -> _
\end_layout

\begin_layout Plain Layout

 > #description="Compute the generic polymorphic sum."
\end_layout

\begin_layout Plain Layout

 > #detail="This operator computes the polymorphic sum of its arguments."
\end_layout

\begin_layout Plain Layout

 > })
\end_layout

\begin_layout Plain Layout

Defined operator sum.
\end_layout

\begin_layout Plain Layout

e> help(sum:OPREF)
\end_layout

\begin_layout Plain Layout

Operator: sum
\end_layout

\begin_layout Plain Layout

Compute the generic polymorphic sum.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Prototype:
\end_layout

\begin_layout Plain Layout

  sum .
 (case)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Cases:
\end_layout

\begin_layout Plain Layout

  (%($x:INTEGER) -> $x)
\end_layout

\begin_layout Plain Layout

  (%($x:STRING) -> $x)
\end_layout

\begin_layout Plain Layout

  (%AC($x:INTEGER, $y:INTEGER) -> add($x, $y))
\end_layout

\begin_layout Plain Layout

  (%A($x:STRING, $y:STRING) -> ($x.$y))
\end_layout

\begin_layout Plain Layout

  (ANY -> ANY)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

This operator computes the polymorphic sum of its arguments.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Special-Forms"

\end_inset

Special Forms
\end_layout

\begin_layout Standard
Elision provides an atom called the 
\emph on
special form
\emph default
 that has some associated 
\begin_inset Quotes eld
\end_inset

syntactic sugar
\begin_inset Quotes erd
\end_inset

 and is widely used for many purposes.
 This short chapter describes this form.
\end_layout

\begin_layout Section
The Basic Special Form
\end_layout

\begin_layout Standard
The special form is really just an ordered pair of atoms, and can be represented
 as 
\family typewriter
{: atom atom :}
\family default
, where the two atoms can be anything.
 Because of this structure, it is easy to match and rewrite special forms
 (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Matching-and-Rewriting"

\end_inset

).
 The first atom of a special form is called the 
\emph on
tag
\emph default
, and the second atom is called the 
\emph on
content
\emph default
.
 The tag is subject to special interpretation when it is a symbol.
 In this case Elision will perform a lookup and expect the content to have
 a specific structure.
 This representation is called the 
\emph on
two atom
\emph default
 
\emph on
form
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> {: 5 6 :}
\end_layout

\begin_layout Plain Layout

$_repl0 = {: 5 6 :}
\end_layout

\begin_layout Plain Layout

e> {: $x $y :}
\end_layout

\begin_layout Plain Layout

$_repl1 = {: $x $y :}
\end_layout

\begin_layout Plain Layout

e> {: fred $y :}
\end_layout

\begin_layout Plain Layout

$_repl2 = {: fred:SYMBOL $y :}
\end_layout

\begin_layout Plain Layout

e> {: operator $y :}
\end_layout

\begin_layout Plain Layout

ERROR: Form operator:SYMBOL expected bindings as content, but instead found:
 $y.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Many known special forms consist of a symbol as the tag, and bindings as
 the content.
 In fact, this is common enough that there is some 
\begin_inset Quotes eld
\end_inset

syntactic sugar
\begin_inset Quotes erd
\end_inset

 for representing this combination.
 In fact, this alternate form, the 
\emph on
short form
\emph default
, was used to define operators in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Operators"

\end_inset

.
 An opening brace is followed by a symbol tag, then zero or more atoms,
 and then zero or more 
\emph on
bind pairs
\emph default
.
 There are two kinds of bind pairs:
\end_layout

\begin_layout Itemize
A hash mark (
\family typewriter
#
\family default
) followed by a symbol 
\family typewriter
s
\family default
, an equal sign, and an atom 
\family typewriter
a
\family default
.
 This creates the binding 
\family typewriter
s->a
\family default
.
\end_layout

\begin_layout Itemize
A hash mark (
\family typewriter
#
\family default
) followed by a symbol 
\family typewriter
s
\family default
, a space, and then a comma-separated list of atoms 
\family typewriter
a1,a2,
\family default
...
\family typewriter
,aN
\family default
.
 This creates the binding 
\family typewriter
s->%(a1,a2,
\family default
...
\family typewriter
,aN)
\family default
.
\end_layout

\begin_layout Standard
Any number, including zero, bind pairs may be present.
 A list of atoms 
\family typewriter
a1 a2
\family default
 ...

\family typewriter
 aN
\family default
 may be present before any bind pairs.
 If so, then the binding 
\family typewriter
``->a1,a2,
\family default
...
\family typewriter
,aN
\family default
 is created.
\end_layout

\begin_layout Standard
This is really easiest to show with a series of examples.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e> {sara}
\end_layout

\begin_layout Plain Layout

$_repl3 = {: sara:SYMBOL { binds  } :}
\end_layout

\begin_layout Plain Layout

e> {sara 6}
\end_layout

\begin_layout Plain Layout

$_repl4 = {: sara:SYMBOL { binds ``->%(6) } :}
\end_layout

\begin_layout Plain Layout

e> {sara 6 7 8}
\end_layout

\begin_layout Plain Layout

$_repl5 = {: sara:SYMBOL { binds ``->%(6, 7, 8) } :}
\end_layout

\begin_layout Plain Layout

e> {sara #first="Sara" #last="Felton"}
\end_layout

\begin_layout Plain Layout

$_repl6 = {: sara:SYMBOL { binds last -> "Felton" first -> "Sara" } :}
\end_layout

\begin_layout Plain Layout

e> {sara #first="Sara" #last="Felton" #chars Zayre, Thorina}
\end_layout

\begin_layout Plain Layout

$_repl7 = {: sara:SYMBOL { binds last -> "Felton" chars ->
\end_layout

\begin_layout Plain Layout

  %(Zayre:SYMBOL, Thorina:SYMBOL) first -> "Sara" } :}
\end_layout

\begin_layout Plain Layout

e> {sara #first="Sara" #last="Felton" #chars=%(Zayre, Thorina)}
\end_layout

\begin_layout Plain Layout

$_repl8 = {: sara:SYMBOL { binds last -> "Felton" chars ->
\end_layout

\begin_layout Plain Layout

  %(Zayre:SYMBOL, Thorina:SYMBOL) first -> "Sara" } :}
\end_layout

\end_inset

So, if you want to bind 
\family typewriter
key
\family default
 to a single 
\family typewriter
value
\family default
, you can use 
\family typewriter
#key=value
\family default
.
 If you want to bind 
\family typewriter
key
\family default
 to a sequence of values, you can use 
\family typewriter
#key v1, v2, 
\family default
...
 Note that a binding is always created, even when it is empty, since the
 special form must always consist of exactly two atoms.
\end_layout

\begin_layout Standard
The purpose of the special form is to unify many different atoms that have
 varied structure, and provide a consistent way to represent them, to match
 them, and to rewrite them.
 As should be evident from the above example, the short form is usually
 much easier to enter and shorter than the two atom form.
 Any short form can be represented in the two atom form, but not all two
 atom forms can be represented in the short form.
\end_layout

\begin_layout Section
Known Special Forms
\end_layout

\begin_layout Standard
There are several known special forms.
 Bindings are not treated the same as other special forms, simply because
 they are themselves used to define special forms.
 Thus the way bindings are interpreted is a bit different, as you can see
 from the first row of the table below.
 Note the additional syntactic sugar for specifying operators.
 This is described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Symbolic-Operators"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Known-Special-Forms"

\end_inset

Known Special Forms
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="17" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="75col%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tag
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Meaning, Example, and 
\begin_inset Quotes eld
\end_inset

Two Atom
\begin_inset Quotes erd
\end_inset

 Form
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
binds
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interpret the content as a list of bindings.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
{binds x->21 y->19}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
{: binds:SYMBOL %(x->21, y->19) :}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
map
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Map an atom as the left-hand side of an apply to every item in a collection.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
{map add:OPREF}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
{: map:SYMBOL { binds `` -> %(add:OPREF) } :}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
match
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Create an atom that matches other atoms against a pattern.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
{match $op.$arg }
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
{: match:SYMBOL { binds `` -> %(($op.$arg)) } :}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
operator
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Create an operator definition.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
{!foo($x,$y)}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
{operator #name=foo #params=%($x,$y)}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
{: operator:SYMBOL { binds name -> foo:SYMBOL params -> %($x, $y) type ->
 ANY } :}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
rule
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Define a rewrite rule.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
{rule add(neg($x),$y)->0 #rulesets MATH}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
{: rule:SYMBOL { binds `` -> %((add(neg($x), $y) -> 0)) rulesets -> %(MATH:SYMBO
L) } :}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Scala
\end_layout

\begin_layout Plain Layout
Creating a special form is quite easy.
 Use 
\family typewriter
core.SpecialForm(tag, content)
\family default
, where 
\family typewriter
tag
\family default
 is the tag, and 
\family typewriter
content
\family default
 is the content.
 Invoking this method in the companion object will check the catalog of
 known special forms (shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Known-Special-Forms"

\end_inset

).
 The following code creates each of the atoms shown in the table.
\end_layout

\begin_layout LyX-Code
// Create a binding.
 There are easier ways to do this!
\end_layout

\begin_layout LyX-Code
val binds = SpecialForm(
\end_layout

\begin_layout LyX-Code
  Literal('binds),
\end_layout

\begin_layout LyX-Code
  AtomSeq(NoProps,
\end_layout

\begin_layout LyX-Code
    MapPair(Literal('x), 21),
\end_layout

\begin_layout LyX-Code
    MapPair(Literal('y), 19)))
\end_layout

\begin_layout LyX-Code
// Create {map add:OPREF}.
\end_layout

\begin_layout LyX-Code
val map = SpecialForm(
\end_layout

\begin_layout LyX-Code
  Literal('map),
\end_layout

\begin_layout LyX-Code
  Bindings(""->AtomSeq(NoProps, Literal(OPREF,"add"))))
\end_layout

\begin_layout LyX-Code
// Create {match $op.$arg}.
\end_layout

\begin_layout LyX-Code
val mat = SpecialForm(
\end_layout

\begin_layout LyX-Code
  Literal('match),
\end_layout

\begin_layout LyX-Code
  Bindings(""->AtomSeq(NoProps, Apply('op,'arg))))
\end_layout

\begin_layout LyX-Code
// Create {operator #name=foo #params=%($x,$y)}.
\end_layout

\begin_layout LyX-Code
val foo = SpecialForm(
\end_layout

\begin_layout LyX-Code
  Literal('operator),
\end_layout

\begin_layout LyX-Code
  Bindings("name"->Literal('foo), "params"->AtomSeq(NoProps, 'x, 'y)))
\end_layout

\begin_layout LyX-Code
// Create {rule add(neg($x),$y)->0 #rulesets MATH}.
\end_layout

\begin_layout LyX-Code
val List(add, neg) = List("add","neg").map(context.operatorLibrary(_))
\end_layout

\begin_layout LyX-Code
val rule = SpecialForm(
\end_layout

\begin_layout LyX-Code
  Literal('rule),
\end_layout

\begin_layout LyX-Code
  Bindings(""->AtomSeq(NoProps, MapPair(add(neg('x),'y), 0)),
\end_layout

\begin_layout LyX-Code
           "rulesets"->AtomSeq(NoProps, Literal('MATH))))
\end_layout

\begin_layout Plain Layout
These examples show direct use of the 
\family typewriter
core.SpecialForm
\family default
 object.
 Of course, each of the above has its own simpler, dedicated method of creating
 an instance.
 For example, the simpler method of creating 
\family typewriter
core.Bindings
\family default
 instances is shown several times above.
 The following create the same special form instances.
\end_layout

\begin_layout LyX-Code
// Create a binding.
\end_layout

\begin_layout LyX-Code
val binds = Bindings("x"->21, "y"->19)
\end_layout

\begin_layout LyX-Code
// Create {map add:OPREF}.
\end_layout

\begin_layout LyX-Code
val map = MapStrategy(Literal(OPREF, 'add), AtomSeq(), AtomSeq())
\end_layout

\begin_layout LyX-Code
// Create {match $op.$arg}.
\end_layout

\begin_layout LyX-Code
val mat = MatchAtom(Apply('op, 'arg))
\end_layout

\begin_layout LyX-Code
// Create {operator #name=foo #params=%($x,$y)}.
\end_layout

\begin_layout LyX-Code
val foo = TypedSymbolicOperator("foo", ANY, AtomSeq(NoProps, 'x, 'y), "",
 "")
\end_layout

\begin_layout LyX-Code
// Create {rule add(neg($x),$y)->0 #rulesets MATH}.
\end_layout

\begin_layout LyX-Code
val List(add, neg) = List("add","neg").map(context.operatorLibrary(_))
\end_layout

\begin_layout LyX-Code
val rule = RewriteRule(add(neg('x),'y), 0, Seq(), Set("MATH"))
\end_layout

\begin_layout Plain Layout
There is yet one more way to create a special form.
 You can create and populate an instance of 
\family typewriter
core.SpecialFormHolder
\family default
.
 This is how the parser functions; it detects a special form, populates
 an instance of this object, and then passes it to an apply method that
 creates the appropriate special form.
 Since its primary use is to support parsers, it is not discussed here.
 Note that every special form instance, no matter how created, holds an
 instance of this class.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Matching-and-Rewriting"

\end_inset

Matching and Rewriting
\end_layout

\begin_layout Standard
Elision is a term rewriter; its primary purpose is matching and rewriting.
 This chapter provides an introduction to matching and rewriting, and to
 the mechanics of how Elision performs these tasks.
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Rules-and-Strategies"

\end_inset

Rules and Strategies
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Contexts"

\end_inset

Contexts
\end_layout

\begin_layout Chapter
\start_of_appendix
BasicAtom
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:De-Bruijn-Indices"

\end_inset

De Bruijn Indices
\end_layout

\begin_layout Standard
Elision converts lambdas into a representation using a form of De Bruijn
 indices.
 This appendix describes how they are implemented in Elision.
\end_layout

\begin_layout Standard
A 
\begin_inset Quotes eld
\end_inset

proper
\begin_inset Quotes erd
\end_inset

 De Bruijn index indicates the the number of binds that are in scope.
 Thus the lambda 
\begin_inset Formula $\lambda x.\lambda y.x$
\end_inset

 should correctly produce the De Bruijn term 
\begin_inset Formula $\lambda\lambda2$
\end_inset

, as the body binds to the outermost lambda.
 Elision does not actually use proper De Bruijn indices, but uses a very
 similar concept somewhere in between symbolic names and De Bruijn indices.
\end_layout

\begin_layout Standard
In Elision every atom has an associated De Bruijn index.
 Literals and (most) variables have index zero.
 Other terms have De Bruijn index equal to the maximum index of their parts.
\end_layout

\begin_layout Standard
Suppose we are given a lambda term such as 
\family typewriter

\backslash
$x.add($x,$y)
\family default
.
 The body contains no lambdas or De Bruijn indices, so it has De Bruijn
 index zero.
 The lambda parameter also contains no lambdas or De Bruijn indices, so
 it also has De Bruijn index zero.
 Thus the maximum De Bruijn index of the parts is zero.
 Since we are constructing a lambda, we increment the maximum index, obtaining
 one.
 The system constructs a special variable 
\family typewriter
$`:1`
\family default
 representing the De Bruijn index, and then rewrites lambda parameter and
 body with 
\family typewriter
$x -> $`:1`
\family default
, obtaining the result 
\family typewriter

\backslash
$`:1`.add($`:1`, $y)
\family default
.
\end_layout

\begin_layout Standard
Next consider 
\family typewriter

\backslash
$x.
\backslash
$y.$x
\family default
.
 First 
\family typewriter

\backslash
$y.$x
\family default
 is constructed, yielding 
\family typewriter

\backslash
$`:1`.$x
\family default
, whose Dr Bruijn index (assigned by Elision) is one.
 Next we construct 
\family typewriter

\backslash
$x.(
\backslash
$`:1`.$x)
\family default
.
 The De Bruijn index of the parameter is zero, and of the body is one, so
 the De Bruijn index to use for the new expression is 
\family typewriter
$`:2`
\family default
, and we rewrite with 
\family typewriter
$x -> $`:2`
\family default
.
 The trick is that the rewrite actually causes us to re-build the lambdas.
 Rewriting the body 
\family typewriter

\backslash
$`:1`.$x
\family default
 results in a new lambda whose body is 
\family typewriter

\backslash
$`:2`
\family default
 with De Bruijn index of two, and thus the entire lambda constructs a new
 
\end_layout

\begin_layout Chapter
The Elision Directory Structure
\end_layout

\begin_layout Standard
The Elision repository contains several files and folders.
 This appendix explains what these items are, where to find them, and where
 to put stuff if you want to contribute.
 The description here contains items that are 
\emph on
not
\emph default
 part of the built distribution, since many of these are not required by
 the distribution.
 This description also contains items that are 
\emph on
not
\emph default
 found in the repository, but are created during the build process.
\end_layout

\begin_layout Section
In the Distribution
\end_layout

\begin_layout Standard
The folders described in the following subsections are part of the Elision
 distribution, created by the 
\family typewriter
dist
\family default
 target in 
\family typewriter
build.xml
\family default
.
\end_layout

\begin_layout Subsection
The Root Folder
\end_layout

\begin_layout Standard
The root of the distribution is reserved for a few files.
\end_layout

\begin_layout Itemize
The 
\family typewriter
README.txt
\family default
 file that describes the distribution and how to build it and start the
 REPL.
 You should only modify this if you need to correct information or document
 a new build.
\end_layout

\begin_layout Itemize
The 
\family typewriter
build.xml
\family default
 file that is used by Ant to compile the system and generate the API documentati
on.
 You should only modify this if you need to change how the system is built.
 This is not needed if you are just adding new source files or third-party
 libraries.
\end_layout

\begin_layout Standard
There are scripts present in this folder.
\end_layout

\begin_layout Itemize
The 
\family typewriter
repl.sh
\family default
 script sets up the 
\family typewriter
CLASSPATH
\family default
 and invokes the Elision REPL.
 This is a Bash script that is only useful on UNIX, Mac OS X, and Linux
 machines, or on Windows machines with Cygwin.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Elision is developed on Mac OS X and Linux platforms, and only occasionally
 tested on Windows, so YMMV.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The 
\family typewriter
run.sh
\family default
 script sets up the 
\family typewriter
CLASSPATH
\family default
 and then starts the Scala interpreter.This is a Bash script that is only
 useful on UNIX, Mac OS X, and Linux machines, or on Windows machines with
 Cygwin.
\end_layout

\begin_layout Standard
In general do not place any other items in the root folder.
 Instead, put them in the appropriate subfolder.
\end_layout

\begin_layout Subsection
The 
\family typewriter
etc
\family default
 Folder
\end_layout

\begin_layout Standard
This folder is reserved for the following items.
\end_layout

\begin_layout Itemize
The 
\family typewriter
config.xml
\family default
 file that provides the template for the system's runtime configuration,
 and the 
\family typewriter
elision_configuration.dtd
\family default
 that describes the format of the configuration file.
 You should not need to modify either of these unless you are modifying
 the 
\family typewriter
ornl.elision.Version
\family default
 object.
\end_layout

\begin_layout Itemize
Files that provide Elision support for editors or IDE's, such as Emacs,
 Eclipse, Sublime, and others.
\end_layout

\begin_layout Itemize
Miscellaneous files, such as properties files for use in Eclipse, if desired.
\end_layout

\begin_layout Standard
If you have a file or files you need to add, and have no other place to
 put it, this is the place it belongs.
\end_layout

\begin_layout Subsection
The 
\family typewriter
doc
\family default
 Folder
\end_layout

\begin_layout Standard
This folder contains the Elision documentation, other than the 
\family typewriter
README.txt
\family default
 file.
 Specifically, it contains the following.
\end_layout

\begin_layout Itemize
This file, 
\family typewriter
elision.pdf
\family default
.
\end_layout

\begin_layout Itemize
The 
\family typewriter
elision.lyx
\family default
 file.
 This is a LyX
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
LyX is an editor that is backed by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LaTeX
\end_layout

\end_inset

.
 If you want to edit this document, you need LyX.
 Fortunately it runs on almost every platform out there.
 Visit 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://lyx.org
\end_layout

\end_inset

 for more information and links to the latest version.
\end_layout

\end_inset

 source file that is converted into 
\family typewriter
elision.pdf
\family default
, and contains the user and developer documentation you are reading right
 now.
\end_layout

\begin_layout Itemize
The 
\family typewriter
makedoc.sh
\family default
 script that will compile the API documentation without requiring you to
 have Ant.
 This file runs the Scaladoc command and puts the documentation in the 
\family typewriter
api
\family default
 subfolder, the same as the 
\family typewriter
build.xml
\family default
 script does.
 This is a Bash script, and should work on UNIX and Mac OS X, Linux, and
 possibly on Windows under Cygwin.
\end_layout

\begin_layout Itemize
The 
\family typewriter
index.html
\family default
 file used by the Elision web site.
\end_layout

\begin_layout Itemize
If the API documentation has been built, either by running the 
\family typewriter
makedoc.sh
\family default
 script or by running the Ant build and specifying the 
\family typewriter
doc
\family default
 target, then there will be an 
\family typewriter
api
\family default
 folder containing the API documentation.
 Point your browser to 
\family typewriter
doc/api/index.html
\family default
 to view the documentation.
\end_layout

\begin_layout Standard
Other documentation files should be put in this folder.
\end_layout

\begin_layout Subsection
The 
\family typewriter
lib
\family default
 Folder
\end_layout

\begin_layout Standard
This folder contains third party code necessary to compile and run the system.
 There is a simple rule for this folder: The build and the Bash scripts
 will search this folder for any jar files, and will add all such files
 found to the class path.
\end_layout

\begin_layout Standard
If you need to use third party code in Elision, and you want to contribute
 back to the main distribution, you must first clear the inclusion of the
 code with the maintainers to make sure there are no licensing conflicts,
 and then you should place the distribution in this folder.
 This allows for consistent and rational versioning.
 If the user were required to get and install the third party libraries,
 they might obtain incompatible versions.
\end_layout

\begin_layout Subsection
The 
\family typewriter
src
\family default
 Folder
\end_layout

\begin_layout Standard
This folder contains the source code for Elision, organized into folders
 that mirror the package hierarchy.
 All Elision code should be placed in a package rooted under 
\family typewriter
ornl.elision
\family default
.
 This is where you will place new source files, as well as any extra files
 required by Scaladoc.
\end_layout

\begin_layout Section
From the Build
\end_layout

\begin_layout Standard
The folders described in the following subsections are created by the build
 process.
\end_layout

\begin_layout Subsection
The 
\family typewriter
bin
\family default
 Folder
\end_layout

\begin_layout Standard
This folder is created by the build process and contains the compiled class
 files and other elements that should be in the class path.
 In fact, the executable jar file is created by compressing this folder
 and adding a manifest, as specified in the 
\family typewriter
build.xml
\family default
 file.
 Anything that should be in the class path should be placed in this folder.
\end_layout

\begin_layout Subsection
The 
\family typewriter
latest
\family default
 Folder
\end_layout

\begin_layout Standard
This folder is created by the build process and contains the most recently
 built executable 
\family typewriter
elision.jar
\family default
 file.
 Any jar files in the third-party library folder (
\family typewriter
lib
\family default
) are included in this file.
 This file can be executed with the 
\family typewriter
scala
\family default
 command, so 
\family typewriter
scala latest/elision.jar
\family default
 will start the REPL.
 Nothing else should be present in this folder.
\end_layout

\begin_layout Subsection
Date-Stamped Folder(s)
\end_layout

\begin_layout Standard
Every time the system is built, it creates a folder whose name is the current
 date, in 
\family typewriter
YYYYMMDD
\family default
 format.
 This folder contains two items: the same 
\family typewriter
elision.jar
\family default
 file found in the 
\family typewriter
latest
\family default
 folder, and a jar file containing the content of the 
\family typewriter
src
\family default
 folder at the time of the build.
 These folders can be deleted if they are not needed.
 Nothing else should be present in these folders.
\end_layout

\begin_layout Chapter
The Elision Coding Guide
\end_layout

\begin_layout Standard
This chapter describes the general style of coding to use for contributions
 to Elision.
\end_layout

\begin_layout Section
Architectural Rules
\end_layout

\begin_layout Section
Scaladoc
\end_layout

\begin_layout Section
Comments
\end_layout

\begin_layout Section
Returning
\end_layout

\begin_layout Chapter
Grammar
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
term}[1]{
\backslash
fbox{
\backslash
texttt{#1}}}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
citerm}[1]{
\backslash
doublebox{
\backslash
texttt{#1}}}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand
\backslash
defntx[1]{~
\backslash

\backslash
[1em]
\backslash
textbf{#1}~::=~}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand
\backslash
defnt[1]{~
\backslash

\backslash
[1em]
\backslash
textbf{#1}~::=~}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
nt}[1]{
\backslash
emph{#1}}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
ordef}{~
\backslash

\backslash

\backslash
hspace{0.5in}|~}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
shortor}{~|~}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
zeroOrMore}[1]{(#1){*}}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
optional}[1]{(#1)?}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
caret}{
\backslash
textasciicircum{}}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
juxt}{$
\backslash
cdot$}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The grammar for Elision is described in extended Backus-Naur form (EBNF)
 in this appendix.
 Terminals are indicated with text in fixed font, boxed, as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
term{terminal}
\end_layout

\end_inset

.
 Elision is normally case-sensitive, but some terminals are case-insensitive.
 These are indicated with a double box, as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
citerm{terminal}
\end_layout

\end_inset

.
 Nonterminals are indicated with italics, as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nt{nonterminal}
\end_layout

\end_inset

.
 Character ranges in unicode are indicated by a dash, so any single nonzero
 digit is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
term{1}
\end_layout

\end_inset

-
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
term{9}
\end_layout

\end_inset

.
 Productions are indicated with ::=.
 Parentheses indicate grouping.
 If an item may appear zero or more times, this is indicated with a suffixed
 asterisk, as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
zeroOrMore{
\backslash
nt{atom}}
\end_layout

\end_inset

.
 Optional items are indicated with a suffixed question mark, as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
optional{
\backslash
nt{atom}}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In general arbitrary white space is allowed.
 When no whitespace is allowed between two elements of the grammar, the
 elements are joined by a dot, as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
term{
\backslash
#}
\backslash
juxt
\backslash
nt{atom}
\end_layout

\end_inset

.
 The special terminal 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
term{ANY}
\end_layout

\end_inset

 is described at the end, and corresponds to any character other than the
 backslash 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
term{
\backslash
textbackslash}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
defnt{atom-seq} 
\backslash
zeroOrMore{
\backslash
nt{atom}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{atom} 
\backslash
nt{first-atom} 
\backslash
term{->} 
\backslash
nt{first-atom}
\end_layout

\begin_layout Plain Layout


\backslash
ordef
\backslash
nt{first-atom} 
\backslash
zeroOrMore{
\backslash
term{.} 
\backslash
nt{first-atom})}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{first-atom} 
\backslash
term{(} 
\backslash
nt{atom} 
\backslash
term{)}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{special-form}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{lambda}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{apply}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{typed-list}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{alg-prop}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{variable}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{operator-symbol}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{literal}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
nt{number}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
term{
\backslash
caret TYPE}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{special-form} 
\backslash
nt{alternate-operator-def}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
term{
\backslash
{:} 
\backslash
nt{atom} 
\backslash
nt{atom} 
\backslash
term{:
\backslash
}}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
term{
\backslash
{} 
\backslash
nt{atom} 
\backslash
zeroOrMore{
\backslash
nt{atom}}
\end_layout

\begin_layout Plain Layout

		
\backslash
zeroOrMore{
\backslash
nt{sf-bound-atom}|
\backslash
nt{sf-bound-list}} 
\backslash
term{
\backslash
}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{alternate-operator-def} 
\backslash
term{
\backslash
{!}
\end_layout

\begin_layout Plain Layout

	
\backslash
nt{SYMBOL} 
\backslash
term{(} 
\backslash
nt{atom-sequence} 
\backslash
term{)}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{:
\backslash
nt{first-atom}}
\end_layout

\begin_layout Plain Layout

	
\backslash
zeroOrMore{
\backslash
nt{sf-bound-atom} | 
\backslash
nt{sf-bound-list}}
\end_layout

\begin_layout Plain Layout

	
\backslash
term{
\backslash
}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{sf-bound-atom} 
\backslash
term{
\backslash
#}
\backslash
juxt
\backslash
nt{SYMBOL} 
\backslash
term{=} 
\backslash
nt{atom}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{sf-bound-list} 
\backslash
term{
\backslash
#}
\backslash
juxt
\backslash
nt{SYMBOL} 
\backslash
zeroOrMore{
\backslash
nt{atom}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{lambda} 
\backslash
term{
\backslash
textbackslash{}} 
\backslash
nt{variable} 
\backslash
term{.} 
\backslash
nt{first-atom}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{apply} 
\backslash
nt{SYMBOL} 
\backslash
term{(} 
\backslash
nt{atom-sequence} 
\backslash
term{)}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{atom-sequence} 
\backslash
nt{atom} 
\backslash
zeroOrMore{
\backslash
term{,} 
\backslash
nt{atom}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{typed-list} 
\backslash
nt{alg-prop} 
\backslash
term{(} 
\backslash
nt{atom-sequence} 
\backslash
term{)}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{alg-prop} 
\backslash
nt{alg-prop-short}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
term{
\backslash
%}
\backslash
nt{alg-prop-long}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{alg-prop-short} 
\backslash
term{
\backslash
%}
\backslash
juxt 
\backslash
zeroOrMore{
\end_layout

\begin_layout Plain Layout

	
\backslash
citerm{A}
\backslash
optional{
\backslash
term{[}
\backslash
nt{atom}
\backslash
term{]}}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
citerm{C}
\backslash
optional{
\backslash
term{[}
\backslash
nt{atom}
\backslash
term{]}}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
citerm{I}
\backslash
optional{
\backslash
term{[}
\backslash
nt{atom}
\backslash
term{]}}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
citerm{!A}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
citerm{!C}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
citerm{!I}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
citerm{B}
\backslash
term{[}
\backslash
nt{atom}
\backslash
term{]}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
citerm{D}
\backslash
term{[}
\backslash
nt{atom}
\backslash
term{]}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{alg-prop-long} 
\backslash
zeroOrMore{
\end_layout

\begin_layout Plain Layout

	
\backslash
term{absorber} 
\backslash
nt{atom}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
term{identity} 
\backslash
nt{atom}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
optional{
\backslash
term{not}} 
\backslash
term{associative}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
optional{
\backslash
term{not}} 
\backslash
term{commutative}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
optional{
\backslash
term{not}} 
\backslash
term{idempotent}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{variable} (
\backslash
term{
\backslash
$}
\backslash
shortor
\backslash
term{
\backslash
$
\backslash
$})
\end_layout

\begin_layout Plain Layout

	
\backslash
nt{SYMBOL}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
term{
\backslash
{} 
\backslash
nt{atom} 
\backslash
term{
\backslash
}}}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
term{:} 
\backslash
nt{first-atom}}
\end_layout

\begin_layout Plain Layout

	
\backslash
zeroOrMore{
\backslash
term{@} 
\backslash
nt{SYMBOL}}
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout


\backslash
defnt{operator-symbol} 
\backslash
nt{SYMBOL} 
\backslash
term{:} 
\backslash
term{OPTYPE}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{literal} 
\backslash
nt{SYMBOL}
\backslash
shortor
\backslash
nt{STRING}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{number} 
\backslash
nt{any-number} 
\backslash
optional{
\backslash
term{:} 
\backslash
nt{first-atom}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{any-number} 
\backslash
nt{hex-number}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor 
\backslash
nt{hex-number}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor 
\backslash
nt{binary-number}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor 
\backslash
nt{decimal-number}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor 
\backslash
nt{octal-number}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{hex-number} 
\backslash
nt{hex-integer}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
juxt
\backslash
term{.}
\backslash
nt{hex-digit}}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
juxt
\backslash
citerm{P}
\backslash
juxt
\backslash
nt{exponent}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{binary-number}
\backslash
nt{binary-integer}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
juxt
\backslash
term{.}
\backslash
juxt
\backslash
nt{binary-digit}}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
juxt(
\backslash
citerm{E}
\backslash
shortor
\backslash
citerm{P})
\backslash
juxt
\backslash
nt{exponent}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{decimal-number}
\backslash
nt{decimal-integer}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
juxt
\backslash
term{.}
\backslash
juxt
\backslash
nt{decimal-digit}}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
juxt(
\backslash
citerm{E}
\backslash
shortor
\backslash
citerm{P})
\backslash
juxt
\backslash
nt{exponent}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{octal-number}
\backslash
nt{octal-integer}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
juxt
\backslash
term{.}
\backslash
juxt
\backslash
nt{octal-digit}}
\end_layout

\begin_layout Plain Layout

	
\backslash
optional{
\backslash
juxt(
\backslash
citerm{E}
\backslash
shortor
\backslash
citerm{P})
\backslash
juxt
\backslash
nt{exponent}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{exponent} 
\backslash
optional{
\backslash
term{-}
\backslash
shortor
\backslash
term{+}} 
\backslash
juxt
\backslash
nt{any-integer}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{any-integer} 
\backslash
nt{hex-integer}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor 
\backslash
nt{hex-integer}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor 
\backslash
nt{binary-integer}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor 
\backslash
nt{decimal-integer}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor 
\backslash
nt{octal-integer}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{hex-integer} 
\backslash
citerm{0X} 
\backslash
juxt
\backslash
zeroOrMore{
\backslash
nt{hex-digit}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{binary-integer} 
\backslash
citerm{0B} 
\backslash
juxt
\backslash
zeroOrMore{
\backslash
term{0}
\backslash
shortor
\backslash
term{1}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{decimal-integer} 
\backslash
term{1}-
\backslash
term{9} 
\backslash
juxt
\backslash
zeroOrMore{
\backslash
nt{digit}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{octal-integer} 
\backslash
term{0} 
\backslash
juxt
\backslash
zeroOrMore{
\backslash
term{0}-
\backslash
term{7}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{hex-digit} 
\backslash
citerm{A}-
\backslash
citerm{F}
\backslash
shortor
\backslash
nt{digit}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{SYMBOL} (
\backslash
nt{letter}
\backslash
shortor
\backslash
term{
\backslash
_}) 
\backslash
juxt
\backslash
zeroOrMore{
\backslash
nt{letter}
\backslash
shortor
\backslash
nt{digit}
\backslash
shortor
\backslash
term{
\backslash
_}}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
term{`} 
\backslash
juxt
\backslash
zeroOrMore{
\backslash
nt{escape}
\backslash
shortor
\backslash
nt{ANY}} 
\backslash
juxt
\backslash
term{`}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{STRING} 
\backslash
term{"} 
\backslash
juxt
\backslash
zeroOrMore{
\backslash
nt{escape}
\backslash
shortor 
\backslash
nt{ANY}} 
\backslash
juxt
\backslash
term{"}
\end_layout

\begin_layout Plain Layout

	
\backslash
ordef
\backslash
term{"""} 
\backslash
juxt
\backslash
zeroOrMore{
\backslash
nt{ANY}} 
\backslash
juxt
\backslash
term{"""}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{escape} 
\backslash
term{
\backslash
textbackslash{}"}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor
\backslash
term{
\backslash
textbackslash{}"}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor
\backslash
term{
\backslash
textbackslash{}'}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor
\backslash
term{
\backslash
textbackslash{}n}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor
\backslash
term{
\backslash
textbackslash{}r}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor
\backslash
term{
\backslash
textbackslash{}t}
\end_layout

\begin_layout Plain Layout

	
\backslash
shortor
\backslash
term{
\backslash
textbackslash{}
\backslash
textbackslash{}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{letter} 
\backslash
citerm{A}-
\backslash
citerm{Z}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{digit} 
\backslash
term{0}-
\backslash
term{9}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
defnt{ANY} 
\backslash
emph{Any character other than} 
\backslash
term{
\backslash
textbackslash{}}.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_body
\end_document
