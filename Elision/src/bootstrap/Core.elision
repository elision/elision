/*======================================================================
 *       _ _     _
 *   ___| (_)___(_) ___  _ __
 *  / _ \ | / __| |/ _ \| '_ \
 * |  __/ | \__ \ | (_) | | | |
 *  \___|_|_|___/_|\___/|_| |_|
 * The Elision Term Rewriter
 * 
 * Copyright (c) 2012 by UT-Battelle, LLC.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * Collection of administrative costs for redistribution of the source code or
 * binary form is allowed. However, collection of a royalty or other fee in excess
 * of good faith amount for cost recovery for such redistribution is prohibited.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER, THE DOE, OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
======================================================================*/

//======================================================================
// Meta.
//======================================================================

def({! eval($atom)
      #description="Force fast rewrite using the current bindings."
      #detail=
"""The context bindings are typically applied after an atom is parsed
and constructed.  This forces any bound variables in $atom to be 
rewritten immediately.  It is most useful when $atom is the argument
to some other operator."""
})

def({ operator #name=typeof #cases %($x:$T)->$T
      #description="Extract and show the type of the argument."
      #detail=
"""Given a single argument, extract the type $T of that argument $x
and return the extracted type."""
})

def({! getop($x: OPREF)
      #description="Given an operator reference, return the operator."
      #detail=
"""Given the operator reference $x, resolve the reference to the
actual operator and return the operator."""
})

def({! setdebruijn($enable: BOOLEAN)
      #description="Enable or disable the use of DeBruijn indices."
      #detail=
"""Specify whether to use DeBruijn indices for lambdas.  Disabling this is
only useful when you are debugging lambdas."""
})

def({! is_bindable($x): BOOLEAN
      #description="Determine whether an atom is bindable."
      #detail=
"""If the atom $x is bindable, return true.  Otherwise, return false.  This
is primarily useful for guards.  You will probably need to protect
variables by making them into metavariables ($$ instead of $) to
prevent zealous evaluation."""
})

//======================================================================
// Help system.
//======================================================================

def({! _help_op($r: OPREF)
      #description="Display detailed help for an operator."
      #detail=
"""Display help text for the operator referenced by $r."""
})

def({! _help_all()
      #description="Display a list of known operators."
      #detail=
"""Display a list of known operators, along with a short description
of each one (if given).  Operators whose name begins with an underscore
are suppressed in this list."""
})

def({ operator #name=help
      #cases
            %($r:OPREF)->_help_op($r), 
            help_all:OPREF
      #description="Get general help or help on an operator."
      #detail=
"""With no argument, list all operators.  If provided with an operator
reference, give detailed help on that operator."""
})

//======================================================================
// File management.
//======================================================================

def({! read($filename: STRING)
      #description="Read the content of the specified file."
      #detail=
"""Read the file specified by $filename, executing each line of the
file as though it were typed at the REPL prompt while quiet mode was
in effect (so most output is suppressed).  No numbered repl bindings
are generated from this action."""
})

def({! write($filename: STRING)
      #description="Write the content of the current context to a file."
      #detail=
"""Write the current context to the file specified by $filename."""
})

//======================================================================
// Manage bindings.
//======================================================================

def({! bind($v,$a)
      #description="Bind a variable to an atom."
      #detail=
"""Bind the variable $v to the atom $a in the current context.  Variable
bindings are applied after an atom is parsed and constructed, but before
it is displayed by the REPL.  Variables can be arbitrarily re-bound."""
})

def({! unbind($v)
      #description="Unbind a variable."
      #detail=
"""Forget any binding for variable $v in the current context."""
})

def({! showbinds()
      #description="Show the bindings in the current context."
      #detail=
"""Show all the bindings present in the current context, except for
bindings to variables whose name starts with an underscore, as these
are considered "private." """
})

//======================================================================
// Tracing and timing.
//======================================================================

def({! traceparse()
      #description="Toggle tracing of the parser."
      #detail=
"""Enable or disable tracingin the parser.  This is really only useful
if you are trying to debug the parser, and want to know in excruciating
detail how something parses.  It may generate a *lot* of output.

This is optional; if multiple parsers are present, some may not support
tracing."""
})

def({! tracematch()
      #description="Toggle tracing of matching attempts."
      #detail=
"""Enable or disable tracing of match attempts.  This generates output
from the matcher as it attempts to match atoms.  The matcher is called
for a variety of reasons, so you may see some unexpected output here."""
})

def({! timing($f:BOOLEAN)
      #description="Toggle showing the evaluation time."
      #detail=
"""Toggle showing the total elapsed "wall clock" time to evaluate an
atom.  The result shows minutes, seconds, and milliseconds."""
})

//======================================================================
// Display.
//======================================================================

def({! showscala()
      #description="Toggle showing the Scala version of parsed atoms."
      #detail=
"""Enable or disable display of the Scala code to create each atom that
the system displays.  The assumption is that you have imported the core
package for Elision."""
})

def({! showprior()
      #description=
"Toggle showing the atom prior to applying bindings and rewriting."
      #detail=
"""When enabled, additional output is generated that shows the parsed atom
prior to applying any bindings from the current context and prior to any
rewriting attempts."""
})

def({! quiet()
      #description="Toggle disable most output."
      #detail=
"""Enable or disable printing of most output.  Explicitly requested output is
always displayed (such as operator help).  Quiet mode is indicated with the
q> prompt."""
})

def({! history()
      #description="Show the current history."
      #detail=
"""Show the current history of lines executed.  This history is numbered,
and numbered items in the history can be recalled later.  The history
is saved between sessions, if possible."""
})

//======================================================================
// Error reporting.
//======================================================================

def({! fail()
      #description="Generate a runtime exception."
      #detail=
"""Generate a runtime exception (a VerifyError).  This causes a core dump and
may be useful if you are trying to debug the system."""
})

def({! stacktrace()
      #description="Toggle whether or not a stack trace is shown."
      #detail=
"""For non-Elision exceptions the exception message is shown, but the
stack trace is typically suppressed (this is not true for runtime
erorrs; the stack trace is always shown for these).  This will enable
(or disable) showing the stack trace for all non-Elision exceptions."""
})
